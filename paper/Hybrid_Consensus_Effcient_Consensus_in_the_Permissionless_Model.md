# 混合共识:无需许可的新型高效的共识
###### 翻译：刘乐元 
## 摘要
共识，或状态机复制是分布式系统和现代密码学的基础构建块。经典的，许可的环境中达成共识已经在30年的分布式系统文献中中得到了广泛的研究。比特币和其他分散加密货币的最新发展在“无许可”环境中普及了一种新形式的共识，任何人都可以动态加入和离开，并且没有对共识节点的先验知识。尽管有了这一令人兴奋的突破，今天的无许可共识协议，通常被称为“区块链”，却被认为有糟糕的表现，这导致了社区的争论，有时甚至是十分激烈的争论。首先，我们表明不幸的是，对于任何能够抵御至少三分之一破坏力的协议来说，性能损失是固有的。 具体来说，我们正式定义了一种称为响应的新性能度量，并且表明任何响应式的无授权共识协议都不能容忍1/3或更多的损坏。 接下来，我们展示一个紧密匹配的上界。 具体而言，我们提出了一项新的无权限协商一致协议，称为混合共识，该协议具有响应能力，能够抵御（大约）1/3的破坏。混合共识的想法是通过将低效的区块链协议与快速许可的共识协议相结合来引导快速的无许可共识。 混合共识使用区块链不同意交易，但同意轮流委员会，轮流委员会依次执行许可的共识协议让交易达成一致。我们的论文是第一个对如何正确地将工作区块链的证明与经典共识相结合的方法进行正式处理，以实现一个响应性的无许可共识协议。我们的努力揭示了许多重要的技术细节和挑战，这些都是对协议正确性的关键，但却被早期和并发的临时方法所忽视。
## 1 介绍
分布式系统和加密技术传统上一直关注于那些被预先知道的参与者。比特币的迅速崛起代表着一项激动人心的突破：比特币的经验表明，通过利用诸如工作证明之类的假设，非简单的安全应用程序可以建立在一个完全分散的网络之上，在这个网络中，节点可以自由和动态地连接和离开，而且参与者之间也没有预先建立的信任。在剩下的论文中，我们将分别将这两个网络设置称为许可设置和无许可设置。

从非正式的角度来说，比特币的核心共识协议，通常被称为Nakamoto共识<font color=#FF0000>[46]</font>，实现了一个“复制状态机”的抽象，在一个无许可的网络中，节点可以就一组提交的事务以及它们的排序达成一致。由于协议依赖于交易块的链接，所以它通常被称为“区块链”。在传统的许可模式中达成共识是一个经典的分布式系统问题，并且有一长串的研究试图设计和优化拜占庭式的共识协议<font color=#FF0000>[21,25,42]</font>。我们可以在一个无许可的模式（依赖于工作量证明）中获得共识，这是比特币的新贡献。从某种意义上说，比特币普及了一种新的分布式系统模型，这种模式在30年的经典分布式系统文献中很少被考虑。

然而，众所周知的“无许可共识”协议，如比特币的Nakamoto共识<font color=#FF0000>[46]</font>是有代价的。由于节点的身份不是预先知道的，所以必须防御Sybil攻击<font color=#FF0000>（可翻译为女巫攻击）</font>，在这种攻击中，攻击者可以任意地使用多个身份来胜过诚实的节点。比特币协议严格地依赖于工作的证明，以大致执行“每个hashpower一票”的概念。不幸的是，比特币的表现非常糟糕。正如Croman等人<font color=#FF0000>[22]</font>指出的那样，比特币网络最多可以维持7tx/秒，交易时间为10分钟以上（参见Visa等主流支付处理平均处理速度为2000tx/秒，峰值速率59000tx/秒）。此外，如果我们要在所有的交易中摊销网络的总耗电量，每一笔交易的成本大约在1美元到6美元之间——今天，这种成本在某种程度上是由比特币的投机者提供补贴的。

这自然引出了一个重要的问题。

*在无许可模式下，是否有可能设计出一种有效的共识协议？*

我们在本文中正式探讨这个重要的问题。

### 1.1 我们的结果和贡献
**了解限制：性能与安全性。** 为了更好地理解这一点，让我们首先试着理解为什么Nakamoto共识<font color=#FF0000>[46]</font>（比特币所采用）是低效的。正如Garay<font color=#FF0000>[30]</font>和Pass<font color=#FF0000>[70]</font>指出的那样，Nakamoto共识协议至关重要的是依赖于对网络延迟的上界的先验知识（下文称为Δ）来参数化它的难题，协议的交易确认时间大致为O（λΔ）至实现ex（-Ω（λ））安全性失败——考虑这种情况的一种方式是块间隔需要为O（Δ）以实现对任何不变的破坏部分（在hashpower中）的安全性，并且必须等待O（λ）块来获取exp（-Ω（λ））安全失败。Nakamoto显然是不高效的，因为先验参数需要保守地设置以保证协议的安全性;并且交易确认时间在估计中会出现松动Δ虽然目前还有其他可能的效率指标，但我们现在将重点关注这一指标。

因此，一个自然而然的问题是，我们是否可以有一个协议，其交易确认时间仅取决于网络的实际性能，而不是任何先验已知的上限。我们正式定义了一个称为响应性的性能指标<font color=#FF0000><sup>1</sup></font>，它捕捉了这种直觉：如果一个协议的交易确认时间仅取决于网络的实际延迟δ，而不是任何一个先前已知的上限，那么协议被认为是响应式的Δ（或者根本不知道先验上限是已知的）。特别是在实践中，实际的δ通常（小得多）小于上限Δ。在这种情况下，响应能力将成为衡量绩效的有效指标。

**定理1.** *（非正式的）没有安全和响应性的协商一致协议可以容忍1/3或更多的腐败，即使当对手受到静态腐败的限制——这在经典的许可设置（即使假定为PKI）中也是如此，以及在工作量证明的情况下进行无许可限制的情况下（其中腐败情况是以散列的形式表示的）。*

坏消息是，我们表明，没有一个反应一致的共识协议能够容忍1/3或更多的腐败，即使对手受到限制，只能静态地腐蚀政党。这个下界的结果既包含在经典的许可设置中（甚至在PKI被假定的情况下），也包含在工作量证明的无许可的设置中——在这个设置中，腐败被计算为hashpower而不是节点的数量。从这个角度来看，观察Nakamoto没有反应，但可以容忍在hashpower<font color=#FF0000>[47]</font>中有1/2的腐败。

这个下界的证明与Dwork等<font color=#FF0000>[25]</font>的下界有关，他们指出，在一个异步（或部分同步）网络中，没有经典的许可共识协议（即使是PKI）也不能容忍1/3或更多的拜占庭式的腐败。在我们的论文中，我们将展示如何使他们的证明适应无许可和工作证明的设置，以及响应的协议。

**一种具有（几乎）最佳弹性的响应性协议。**
下一个明显的问题是：假设我们愿意放松模型，并假设在hashpower中只有<1/3的腐败，我们能在无许可的环境中有一个响应一致的协议吗？我们以积极的态度回答这个问题。

**定理2.** *（非正式的）假设一个工作证明随机预言。存在一个响应式的无任何共识协议，可以抵御1/3的**反对轻度自适应攻击者的破坏。*

为此，我们提出混合共识。 混合共识为无许可共识提供了“有效引导”，就像众所周知的混合加密和OT-扩展是“有效引导”结构一样。 由于传统的许可共识<font color=#FF0000>[15,19,21,25,39,40,42,45]</font>已经被研究和优化了数十年，并且已经被证明能够对抗1/3腐败的响应性，我们的想法是使用慢速区块链协议（称为snailchain），如Nakamoto共识<font color=#FF0000>[30,46]</font>来引导快速许可的拜占庭共识，最终的结果是在无权限模型中可扩展的共识协议。 出于这个原因，我们把我们的协议称为“混合共识”。

混合共识是第一个已知的响应式无许可共识协议，甚至是启发式的。我们正式证明，混合共识能够实现针对具有以下功能的恶意（即拜占庭式）攻击者的安全性：1）总计算能力的大约或1/3;2）可以自适应腐败节点，但腐败需要一段时间才能有效（以后称为温和自适应对手）;和3），并可以在传输过程中对消息进行重新排序，并将消息延迟至δ时间步长的界限。

<table>
        <tr>
            <th>Scheme</th>
            <th>TX conf. time</th>
            <th>Processing/tx</th>
            <th>% honest</th>
        </tr>
        <tr>
            <th>Nakamoto [46], BitcoinNG [27]</th>
            <th>Θ(λΔ)</th>
            <th>O(n)</th>
            <th>~1/2</th>
        </tr>
        <tr>
            <th>Fruitchain [48] (concurrent work)</th>
            <th>Θ(λΔ)</th>
            <th>O(n)</th>
            <th>~1/2</th>
        </tr>
        <tr>
            <th>Hybrid consensus over Nakamoto</th>
            <th>Opt: O(δ), Worst: O(λδ)</th>
            <th>O(λ)</th>
            <th>~3/4</th>
        </tr>
        <tr>
            <th>Hybrid consensus over Fruitchain</th>
            <th>Opt: O(δ), Worst: O(λδ)</th>
            <th>O(λ)</th>
            <th>~2/3</th>
        </tr>
    </table>
    
**表1：我们的结果总结。**
n表示节点的总数（假设所有节点具有相等的hashpower）;Δ表示网络传输延迟的预定上限;δ表示网络的实际延迟;λ是用于实现2 <sup>-λ</sup>安全失败的安全参数。

**其他实际好处。**
除了提供响应能力之外，混合共识在实践中还带来了额外的好处：对于智能合同应用程序，它将处理成本降低到O（λ）（即独立于矿工总数），而现有区块链如Nakamoto要求所有矿工执行智能合约。 最后，混合共识可以帮助提高共识协议的整体吞吐量，因为我们预计选举委员会（与完整的对等网络相比）的带宽吞吐量更高。尽管混合共识不会消除工作证明，但它通过在较高的事务吞吐量上分摊工作成本来降低每笔交易的成本。

### 1.2 技术细节和与密切相关工作的比较
尽管在社区中已经讨论了将无许可的共识和许可的共识结合起来的想法（例如，Decker<font color=#FF0000>[23]</font>最近的工作，以及ByzCoin<font color=#FF0000>[37]</font>并行和独立的工作，但是据我们所知，*没有任何先前的工作提供了正式的处理。*

**技术细节。**
正如我们的工作所表明的那样，在构建和证明安全性方面，将许可和无许可限的协议相结合并不是微不足道的。我们的努力揭示了许多微妙之处，如果没有正式的处理就很容易被忽视：例如，如何抵御自私的采矿，达到最佳的适应能力;如何依靠一种连锁的印戳技术来防止委员会的腐败;如何处理对委员会的敌对选择性开放;当多个经典的BFT实例在切换期间同时在短窗口中运行时，如何正确地处理委员会切换以确保共同安全。

**与密切相关的作品比较。** 相比之下，Decker<font color=#FF0000>[23]</font>的先前工作和并行的工作Byzcoin<font color=#FF0000>[37]</font>采取一种启发式的安全方法：经过仔细研究，这些作品似乎忽略了上述一个或多个微妙之处（以及其他细节）。首先，两项工作<font color=#FF0000>[23，37]</font>都声称能够达到最佳的弹性（即容忍1/3的腐败），但他们的声明是不正确的——由于这些作品使用Nakamoto作为潜在的snailchain，由于众所周知的自私采矿攻击<font color=#FF0000>[28]</font>，他们至多可以忍受1/4的腐败，而不会对其协议进行重大的修改。除了这个值得注意的问题外，Byzcoin<font color=#FF0000>[37]</font>协议还存在其他明显的漏洞：例如，它们的协议并没有消除委员会选举中的尾随块，因此可能不会就委员会达成一致意见——这可能会损害一致性和 /或其协议的活跃性（别人也独立观察了这些Byzcoin的漏洞<font color=#FF0000>[1]</font>）。 事实上，自从Byzcoin<font color=#FF0000>[37]</font>在Usenix Security'16发布以来，作者自己已经在随后的博客文章中承认了其中的一些漏洞<font color=#FF0000>[3，4]</font>。 值得注意的是，在他们最近的博客[4]中，他们引用我们的论文作为实现最佳应变能力的潜在解决方案然而，迄今为止，他们仍然没有提供正式的正式协议。由于他们的工作似乎忽略了我们的工作所暴露的多种微妙之处，因此不清楚他们提供的安全保证或他们的协议提供任何保证的安全模型。

因此，我们的工作是截然不同的，因为我们提供了第一个可验证的方法，将工作量证明和经典共识结合起来，以实现响应性。

### 1.3 论文的组织
我们的正式处理遇是一个相当重要的努力（并且如上所述是必要的）——因此为了可读性，在我们给出正式定义，协议描述和证明之前，我们首先在第2部分中提出一个半正式的技术路线图。

## 2 技术路线图
### 2.1 预备和构件块
在这一节中，我们提出半正式或非正式的定义，以获得无许可的共识，这是我们旨在实现的抽象，以及我们依赖的构建块。 正式的定义将在后面的文章中介绍。

#### 2.1.1 无许可的共识
我们的目标是在无许可模式中实现状态机复制抽象——从此称为无许可的共识<font color=#FF0000><sup>2</sup></font>。

在一个无许可的共识协议中，每个节点在每一个时间步骤中输出一个日志——这个日志表示提交的事务集。两个重要的安全要求，即一致性和活跃性必须以压倒性的可能性得到保证。

- 一致性：一致性包括以下内容：

-通用前缀。 假设一个诚实节点i在t时刻输出LOG到Z，而一个诚实节点j（相同或不同）在时间t'
输出LOG'到Z'，它认为LOG<LOG'或LOG'<LOG。这里的关系<意思是“是前一个”。按照惯例，我们假设对于任何∅<x和x<x。

-自适应力。 假设节点i在和t时刻是诚实的并且t'≥t，并分别在时间t和t'输出LOG和LOG'，它认为LOG<LOG'。

- 活力：假设交易TXs是在t≥T<sub>warmmup</sub>时的一个诚实节点的输入，那么，如果在时间t'≥ t+T<sub>confirm</sub>处诚实的节点在时间t'输出LOG，则它认为TXs⊆LOG。

直观地说，活跃度表示交易在T<sub>confirm</sub>时间内包含在诚实节点的LOG中。有两个活跃度参数T<sub>confirm</sub>和T<sub>warmmup</sub>。T<sub>warmmup</sub>是协议的预热时间; 而T<sub>confirm</sub>是交易待确认（在T<sub>warmmup</sub>之后提出）的最大等待时间。

#### 2.1.2 区块链
混合共识依赖于工作证明链（从此称为snail链）作为构建块。一个工作证明的区块链可以被看作是一个无许可共识协议的特例——事实上，我们将在我们的论文的完整版本中正式地展示这一点。Garay <font color=#FF0000>[30]</font>和Pass<font color=#FF0000>[47]</font>提出了区块链的正式抽象概念。在本节中，我们提供了区块链的半正式定义，同时将正式定义推迟到后面的部分。不准确地说，一个snail链满足以下属性。

- 一致性。所有诚实节点的链（在任何时候）都是一致的，除了后面的λ块，其中λ是安全参数。此外，节点的链也与未来的自己一致。
- 链的质量。在一个诚实的节点链中连续的λ区块中，有足够的块被诚实的矿工开采。
- 链增长。诚实节点的链条以稳定的速度增长，既不过快也不过慢。进入翻译页面

#### 2.1.3 许可的BFT
在经典的分布式系统文献中已经对许可的BFT协议进行了广泛的研究。 通常，已知的许可BFT <font color=#FF0000>[21,25,42]</font>完全符合前面定义的一致性和活性保证——但这里是为了获得许可的设置。

混合共识将使用许可的BFT协议作为构建块。结果是，在我们的上下文中，一个有趣的技术上的微妙之处是在形式化了被许可的BFT所需的抽象。基于属性的安全定义（在分布式系统文献中通常是这样做的）由于有选择性的开放攻击而被证明是不充分的。特别是，对手可以先查看节点的公钥，然后自适应地影响委员会的选择方式。在第2部分中，我们认为存在一个（有些人为的）许可的BFT协议，它在基于属性的定义下是可验证的，但是如果受到敌对的选择性开放，它将被完全破坏。

因此，我们定义了一个增强的安全的概念，用于我们的底层许可的BFT构建块。我们不仅需要以压倒性的概率满足上述的一致性和活力属性，我们还需要以下更有力的声明：

有一个p.p.t.的减少β，使任何p.p.t.的对手能够在任何一组公钥上破坏BFT的安全属性，减少β使黑盒对这个对手的调用可以代表一个诚实的政党伪造签名。

在本文的后面，我们将形式化上述概念，并通过增加PBFT算法<font color=#FF0000>[21]</font>来展示如何实现这种抽象。

#### 2.1.4 执行模型
我们考虑一个开放的注册网络，其中包含一个工作预测模型，并且与之前的工作一样，是一个随机预言模型<font color=#FF0000>[30,47]</font>。

**网络的假设。**
我们假设一个部分同步的模型，在这个模型中，一个诚实节点发出的任何消息都保证在δ时间步骤中到达所有诚实的节点。对手被允许根据上述约束重新排序消息。

我们的协议需要知道δ的一个可能松散的上界来参数化该方案（特别地，要对潜在的snail链的难题进行参数化处理）。 我们此后使用符号Δ来表示这个预先确定的上限。我们的协议实现了响应性：即使我们使用先验上限Δ作为输入参数，我们的协议实现的交易确认时间取决于网络的实际延迟δ，而不是可能松散的上限Δ。这个要求使得我们的设置与同步模型有着根本的不同——因为如果协议简单地将Δ时间步骤作为同步轮，则协议将不会响应。

**轻度适应性腐败。** 尽管我们允许攻击者自适应地决定哪些节点损坏，但腐败并不会立即发生。在我们的模型中，当攻击者向节点发出“目标损坏”指令时，节点实际上需要τ时间才会损坏（其中τ将在后面完整版本中进行参数化）。一旦节点实际上变得腐败，攻击者可以杀死该节点。最后，随时可以产生新的节点。

**允许的参数。** 此后，我们将假设底层区块链选择合适的难度参数，这样，期望的块间时间是一个合适的常数分数，比诚实节点之间的网络延迟要大。 本文后面我们将这些可接受性要求正式化。

### 2.2混合共识协议：概述
底层的snail链。 我们构建一个潜在的区块链协议（表示为snail链），其正式抽象由Garay<font color=#FF0000>[30]</font>和PPass<font color=#FF0000>[47]</font>定义。这种snail链抽象有两种可能的实现方式，最初的Nakamoto共识<font color=#FF0000>[30,46，47]</font>和最近的Fruit链<font color=#FF0000>[48]</font>协议。为了概念简洁，在我们的展览中，我们会假设Nakamoto是潜在的snail链。 然而，正如我们稍后解释的那样，将Nakamoto作为snail链使我们能够抵御1/4-∈腐败（在hashpower中）。

Fruit链<font color=#FF0000>[48]</font>实现了与Nakamoto snail链相同的抽象——然而，由于Fruit链可以抵御自私挖矿攻击，它实现了（几乎）理想的链条质量。 正如我们后来所说的，如果我们改为采用Fruit链作为潜在的snail链的替代品，我们可以针对一个任意小的常数ε抵御1/3-∈腐败（在hashpower中），从而实现（几乎）最佳的弹性。顺便提一句，这也证明了模块化协议设计和组合的强大优势。

#### 2.2.1 热身：静态委员会
从根本上说，诸如Nakamoto共识（以下称为snail链）的区块链依赖于工作量证明的难题，使得节点 以建立Sybil-resilient身份。我们的第一个想法是利用snail链来选举一个静态委员会。为此，诚实的节点运行区块链的csize+λ区块，其中csizeΘ（λ）表示目标委员会的规模，λ表示安全参数。此时，一个诚实的节点将从本地链中移除尾随的，不稳定的λ区块，并呼吁第一个大小的矿工阻止BFT委员会<font color=#FF0000><sup>3</sup></font>。

粗略地说，这样的协议在静态腐败模型下可以证明是安全的，这是由于以下原因。
- 由于snailchain的一致性，所有诚实的节点在同一个BFT委员会上达成一致。我们强调，删除尾随的λ不稳定块是很重要的，因为否则诚实的节点对谁应该是BFT委员会有不同的意见（例如，由于snail链中可能存在分叉） - 在这种情况下，我们无法保证协议安全。<font color=#FF0000><sup>4</sup></font>
- 由于snail链的链条质量属性，具有适当的总体参数，我们可以确保2/3以上的委员会成员诚实，足以确保许可的BFT协议的安全性。
- 由于snailchain的链条增长性质，BFT委员会不会花太长时间形成。

最后，委员会成员签署所交易的任何交易以及其序列号。对于任何未被选为委员会成员的节点，它可以简单地计算来自委员会成员的签名数量，以决定其自己的输出日志。由于超过2/3的委员会成员是诚实的，如果至少[1/3|csize|]保证同一交易及其序列号（(即它在输出日志中的相对位置）。不难看出，假设所采用的BFT协议是响应式的，这种简单协议的响应性就成立了。

一个有趣的悖论。 尽管这个提议显然简单，但这个方案仍然令人激动。一个令人感兴趣的明显悖论是：由于我们不再依赖snail链来达成交易，为什么不在委员会选举后停止运行snai链？虽然这个提议最初看起来很诱人，但很快就意识到它并不安全。特别地，对于任何在有限的多项式时间内停止执行工作量证明的协议，一个对手总是可以创建一个与实际执行相同的模拟执行，这样一来，一个晚产生的节点就无法将真实的执行与模拟的执行区分开来。我们在第9部分中形式化了这个下界，并表明任何安全的无许可共识协议都必须经常调用工作量证明（即使对于静态安全和同步模型）。

#### 2.2.2 轻度适应性腐败的处理
从静态到轻度适应性腐败。上述有静态委员会的方案对于适应性对手来说是不安全的，因为对手一旦当选就可以简单地腐化委员会。不幸的是，任何从n个节点向λ大小委员会选择的方案都肯定容易受到这种自适应攻击。

然而，在现实中，一个节点的腐败通常不是即时的，因为它需要一段时间才能感染另一个干净的宿主。因此，我们定义了一个稍微放松但却很现实的腐败模式，即所谓的τ-敏捷的腐败。在这个模型中，粗略地说，一个对手可以向节点发出“目标损坏”指令;然而，一个接收到“目标损坏”的节点直到τ时间之后才会变得腐败。

我们在这个τ-敏捷腐败模型下展示了一个积极的结果。我们的主要想法是依靠轮换委员会。当一个诚实的节点链长度达到R⋅csize+λ时，第R个委员会通过首先删除尾数λ的区块来选出，然后从这个删减的链中选出最后的csize区块的矿工作为委员会。这个想法是，如果一个对手成为一个委员会成员（一旦他挖掘出一个区块（这将允许他被纳入一个委员会）），那就太迟了。有了适当的τ，在节点实际上变得腐败的时候，委员会的任期将会结束，下一个委员会接管了！我们留下一个令人兴奋的开放性问题是否完全适应性安全是否可能用于响应式无许可协议。

**技术挑战。** 虽然高层次的想法可能看起来很简单，但事实证明，定义和处理轻度自适应腐败会引入各种技术细节。 具体来说，我们需要以保证并行组合的方式正确处理委员会切换;而且，对手可以追溯腐败旧委员会的可能性也带来了新的挑战。

**日常操作。** 今后为方便起见，我们会说每个委员会服务一天，并输出每日日志。我们的混合共识协议本质上是输出这些日志的连接。 我们现在描述委员会成员和非成员的日常运作。

- 委员会成员。 在每一天R时，第R委员会将运行一个BFT实例。委员会成员将继续运行BFT协议来提交事务，直到它收到一个“停止”指令，此时将调用一个特殊的停止过程。因此，委员会成员将逐渐输出已承诺的交易。 提交的事务将填充节点的每日日志，记为log<sub>R</sub>。

每当一个诚实的委员会成员向其log<sub>R</sub>添加一个新的事务tx时，它将签署元组（R，l，tx），其中R表示当前日期，l表示当日内tx的序列号。 然后诚实的委员会成员将签名的元组散步给网络。
- 非委员会成员。 非会员从网络上听到已签署的交易。每当一个非成员听到一个元组（R，l，tx）已经被超过1/3的comm<sub>R<sub>成员分数签名时，他就把tx添加到它的log<sub>R</sub>中：

if log<sub>R</sub>[l] is not populated : log<sub>R</sub>[l] := tx

注意，一个非委员会成员可以不按顺序对其log<sub>R</sub>[l]进行写入，因为消息可能会被按顺序接收。但是，在所有之前的事务都被提交之前，交易是不能被处理的。稍后，当我们定义每个节点的输出日志时，我们强制执行事务总是以顺序写入——如果非委员会成员将log<sub>R</sub>的最长连续前缀输出到它的日志中，就可以实现这一点。

**委员会切换。** 每当一个节点进入一个表示R+1的新的日子时，就需要进行委员会切换。正确地实现委员会的切换而不会在两者之间留下不活动的空白是有点棘手的。我们提出一种方法，在每天开始时，新委员会开始新的BFT实例，同时老委员会启动现有实例的停止过程。这会引入一些细微之处，因为在瞬态窗口中，BFT协议的两个（或更多）例可能正在同时执行 - 在这些情况下，节点需要正确线性化多个实例的输出;我们还需要确保多个BFT实例的并发组合。

下面我们首先描述一下以前BFT实例的停止过程;然后，我们将描述节点如何在可能同时执行BFT实例的情况下输出线性化日志。在下面，让R成为前一天。

**先前的委员会成员。** 如果一个节点是第R个委员会的成员，表示为comm<sub>R</sub>，则它向前一个BFT输入一个特殊的带符号停止事务——一个节点可以运行多个BFT虚拟节点，在这种情况下，一个有符号停止事务输入到每个BFT虚拟节点。 当BFT的日志收集足够多的由不同的委员会成员公钥签署的这些停止交易时，日志会被最终确定，并且所有后来的交易都会被忽略。 此时，我们说前一个BFT已经终止。当前一个BFT终止时，comm<sub>R</sub>的一个成员将签署该元组（R，| log<sub>R</sub>|），并将签名的元组传给网络。这允许comm<sub>R</sub>的非成员确定log<sub>R</sub>何时结束。

此外，一个诚实的委员会成员符号（R，hash（log<sub>R</sub>）），其中哈希是抗碰撞的，并将签名的元组放到底层的snail链——我们从此将这个动作称为冲压。正如我们稍后解释的那样，及时的冲压工作可以防止对手在未来对旧的委员会成员进行追溯。

在这一点上，诚实的comm<sub>R</sub>成员输出“完成”。

**非先前的委员会成员。** 如果该节点不是R天的BFT实例的委员会成员，它将等待超过1/3的comm<sub>R</sub>成员分数来担保元组（R，l）。发生这种情况时，它知道l是log<sub>R</sub>的最终序列号。因此，在输出“完成”之前，它只是等待所有的log<sub>R</sub> [l]被填充。

每当一个节点（非成员的成员comm<sub>R</sub>）输出“完成”时，其logR被认为是最终的。我们注意到，诚实的comm<sub>R+1</sub>成员一旦感觉到R+1日的开始，并且不等待他们的logR是最终的，就立即开始R+1日的新BFT实例。 这可以确保所有comm<sub>R+1</sub>成员在短时间内彼此启动新的BFT实例（而等待log<sub>R</sub>为最终会在下一个BFT实例的启动时发生额外漂移）。

**输出一个线性化的日志。**
节点需要将他们的日志记录收集到最终日志中，记录表示为LOG——最后的日志必须满足3.2节定义的属性。尤其是，这个最终的日志LOG以递增顺序输出交易，因为在所有前面的交易已经累计之前，可能无法处理交易。 正如我们所指出的那样，非委员会成员可能会写入其log<sub>R</sub>无序的日志。 此外，当第R日的BFT实例开始时，先前的BFT实例可能没有完全完成，因此log<sub>R</sub>将不得不等待log<sub>RR-1</sub>的最终结果。

因此，要按顺序输出最终的日志LOG，我们只需定义LOG以下的包含：
- 每日日志的最大连续序列log<sub>1</sub>，log<sub>2</sub>，...，log<sub>r-1</sub>，所有这些都必须是最终的。
- 每日日志log'<sub>τ</sub>的最长的连续前缀。

**链上冲压：防止追溯性腐败。**
如果有足够长的时间，一个对手最终可能会腐蚀足够多的BFT委员会成员，在这一点上，对手可以伪造BFT委员会成员的签名，而不是他们选择的任何信息。因此，BFT委员会成员的签名在很长一段时间后都是不值得的。在这种追溯性攻击的可能性下，晚产生的节点不能依赖于计算委员会成员的签名来决定那些太古老的日志。

为了应对这一挑战，我们依靠链上冲压技术。当诚实的BFT委员会成员终止他们的BFT实例时，他们将签署每日日志的元组并且提议该元组作为基础snail链的交易。我们证明，在适当的参数选择下，足够多的诚实的BFT委员会成员的日志元组及时（尤其是在节点实际上变得腐败之前）在snail链上盖章。通过这种方式，生成较晚的节点可以从基础的snail链中恢复过去每日日志的正确元组（而不是计算过时的委员会成员的签名，然后可能会腐败）。我们强调，链上冲压仅适用于后期加入的节点恢复历史日志。在线交易确认只需要对当前委员会的签名进行计数，而不需要等待链上冲压的发生。

#### 2.2.3链的质量和弹性
如果采矿是随机抽选，那么这将是理想的选择，在每个块，大自然都会随机抽取赢家。如果确实如此，那么我们可以获得完美的链质量，即如果α节点的节点损坏，则大致为1-α链质量。不幸的是，之前的一些工作<font color=#FF0000>[28,30,47]</font>表明，由于自私的采矿攻击，Nakamoto共识不能被认为是完美的链票。当诚实的节点挖掘一个块时，他们立即宣布块，但是损坏的节点不需要遵循这个规则当腐败节点从当前最长的链上挖出一块B *块时，它们从公众中扣除块B *并继续在自己的私人分支上挖掘，如果在某些时候诚实的节点碰巧发现了一个新的B块链，那么此时攻击者立即释放块B *，并结合网络冲击攻击，块B *将比B更快地到达其他节点。以这种方式，攻击者已经成功地擦除了诚实节点的工作——事实上，每当腐败节点挖出一个块时，他们就有机会擦除诚实节点的块。因此，Nakamoto共识需要大约3/4的整体诚实才能实现2/3链的质量（并且需要2/3的链质量才能确保2/3的BFT委员会是诚实的）——事实上，这是为什么之前的工作（Decker<font color=#FF0000>[23]</font>和<font color=#FF0000>[37]</font>）声称达到最佳弹性的原因是不正确的。

如果不是Nakamoto共识，我们采用Frui链<font color=#FF0000>[48]</font>作为潜在的区块链协议，可以避免链损失导致的锁质量的损失。如Pass和Shi<font color=#FF0000>[48]</font>所示，Fruit链可以抵御这种自私的采矿攻击，因此可以获得近乎完美的链条质量，即它实现了大约（1-α）链质量，在典型的参数化下达到α<1/2腐败。因此，关于Fruit链的混合共识仅需要2/3的总体诚实hashpower（大约）来实现安全性。

#### 2.2.4 模块化协议组成和形式推理
为了帮助形式推理和演示，我们的协议通过模块化组合方法进行描述。

**Daily offchain共识。** 我们首先构造一个名为DailyBFT的中间抽象，它描述了委员会成员和非成员分别在每天的日志上达成一致。 我们的混合共识协议将为每天的DailyBFT[R]分配一个实例，其中R是日期编号以及DailyBFT实例的唯一会话标识符。 然后混合共识连接这些DailyBFT实例输出的每日日志。

在DailyBFT实例中，每个选出的委员会成员都会产生一个或多个BFT虚拟节点，具体取决于委员会中包含了多少公钥。 如果一个节点没有被选举为委员会，它将计算委员会成员的签名来决定其每日日志。

<table>
        <tr>
            <th>Variable</th>
            <th>Meaning</th>
        </tr>
        <tr>
            <th>tx</th>
            <th>a transaction</th>
        </tr>
        <tr>
            <th>l</th>
            <th>sequence number of a transaction within each BFT instance</th>
        </tr>
        <tr>
            <th>LOG</th>
            <th>the totally ordered log each node outputs, LOG is always populated in order</th>
        </tr>
        <tr>
            <th>log</th>
            <th>log of one BFT instance, referred to as daily log</th>
        </tr>
                <tr>
            <th>log[l:l']</th>
            <th>transactions numbered l to l' in log</th>
        </tr>
                <tr>
            <th>log[:l]</th>
            <th>log[1:l]</th>
        </tr>
                <tr>
            <th>λ</th>
            <th>security parameter</th>
        </tr>
                <tr>
            <th>α</th>
            <th>adversary's fraction of hashpower</th>
        </tr>
              </tr>
                <tr>
            <th>δ</th>
            <th>network's maximum actual delay</th>
        </tr>
              </tr>
                <tr>
            <th>Δ</th>
            <th>a-priori upper bound of the network's delay (typically loose)</th>
        </tr>
              </tr>
                <tr>
            <th>csize</th>
            <th>committee size, our protocol sets csize :=λ</th>
        </tr>
              </tr>
                <tr>
            <th>th</th>
            <th>th :=[csize=3], a threshold</th>
        </tr>
              </tr>
                <tr>
            <th>lower(R); upper(R)</th>
            <th>lower(R) := (R - 1)csize + 1, upper(R) :=R ⋅ csize</th>
        </tr>
              </tr>
                <tr>
            <th>chain</th>
            <th>a node's local chain in the underlying snailchain protocol</th>
        </tr>
              </tr>
                <tr>
            <th>chain[: -λ]</th>
            <th>all but the last λ blocks of a node's local chain</th>
        </tr>
                </tr>
              </tr>
                <tr>
            <th>MinersOf(chain[s : t])</th>
            <th>the public keys that mined each block in chain[s : t]. It is possible that several public keys belong to the same node.</th>
        </tr>
                </tr>
              </tr>
                <tr>
            <th>{msg}<sub>pk</sub><sup>-1</sup></th>
            <th>all but the last λ blocks of a node's local chain</th>
        </tr>
                </tr>
              </tr>
                <tr>
            <th>T<sub>bft</sub></th>
            <th>liveness parameter of the underlying BFT scheme</th>
        </tr>
    </table>
    
**表2：符号**

我们正式确认并证明了DailyBFT的安全特性：阅读5.2节中提供的详细形式化时，需要注意以下几点。

- 虽然较低级别的BFT构件只为委员会成员说明其安全属性（即一致性和活跃性），但在DailyBFT中，这些安全属性也是延伸至非委员会成员的。
- 较低级别的BFT构件假设所有委员会成员都是在BFT实例启动之前产生的。然而，在DailyBFT中，这些安全属性需要延伸到可能在后期产生的非委员会成员（但不会太晚）。
- 另一方面，DailyBFT不能保证加入太晚的节点的安全性（即一致性和活跃性），因为委员会成员未来可能会很腐败，此时委员会成员可以签署任意元组，从而延迟加入 节点不能依赖计数签名来决定他们的每日日志。我们把它推迟到混合共识来应对这种攻击，通过检查每天在snail链上加盖的日志来加入节点来恢复古老的日志。
- DailyBFT提供了一个关键抽象：在每个keygen查询中，DailyBFT生成并输出一个新的矿工公钥pk——混合共识协议将把pk合并到被挖掘的块中。之后，DailyBFT将接收来自已选择一组pks作为委员会成员的环境的输入。这是处理委员会密钥的敌对选择性开放的处理方式。 因此，DailyBFT的安全性证明利用了BFT协议的强大安全性，认为当在DailyBFT内作为子协议运行时，BFT协议将遵守所述的安全属性，包括一致性和活跃性——否则可以构建一个约简但这打破了签名安全。
- 最后，与BFT相比，DailyBFT还实现了一个终止过程，它满足两个属性，即及时终止和终止协议。及时终止就是，BFT协议在收到停止指令的诚实节点上迅速终止。终止协议就是，所有诚实的节点在终止时输出相同的最终日志。通过使用诚实的BFT虚拟节点输入一个特殊的、已签名的停止事务到底层BFT，从而实现终止。当有[|comm|/3]停止由不同的委员会成员密钥签名的交易已经累积在日志中时，所有稍后的交易都将被忽略，并且日志已最终确定。

**混合共识**
我们现在描述我们的最终产品，混合共识协议。混合共识消耗了大量的DailyBFT实例，在这些情况下，轮流委员会在日常日志上达成一致。混合共识主要有以下几点：

- 它使用snail链作为一个全局时钟来管理DailyBFT实例的生成和终止，这是在诚实节点之间实现弱同步;
- 回想一下，每个DailyBFT实例都不能确保生成太晚的节点的安全性，因为委员会成员在将来会变得很腐败，在这一点上他们可以签署任意的元组。因此，混合共识引入了一种链上的戳记机制，以将安全保证扩展到即使是晚产生的节点。具体来说，委员会成员在他们的BFT实例终止时将他们签名的每日日志标记到snail链上。晚产生的节点将依赖于这个链上的标记来识别和恢复过去的日志（而不是计算off-chain的签名）

#### 2.2.5 主要定理

下面我们陈述一下我们的主要定理：通过将Fruit链作为混合共识的基础，我们获得了第一个响应性的无许可共识协议，具有最优的弹性。主要定理的证明将在稍后的论文中提出。

令α表示对抗分数，令ρ表示单个节点在每个时间步中挖掘块的概率，令λ表示混合共识的安全参数，并且令η为混合共识期望的附加参数（例如委员会大小将被选为λ/η），令κ表示基础Fruit链协议的安全参数，我们有以下定理：

**定理3**（关于Fruit链的混合共识）。对于任意（任意小）常ε> 0，假设α= 1/3-ε，对于每n，δ存在足够小的ρ：=（Θ/δn），合适的κ=Θ（λ），并且常数η>0，使得HybridConsensus<sup>λ,η</sup>， 在带有参数（ρ，κ）的Fruit链上，被保护的w.r.t.和所有的p.p.t.（n，α，δ，τ）-有效的（A，Z）对于任何合适的τ使得Γ<sup>hcfruit</sup><sub>ρ,η</sub>=<font color=#FF0000><sup>5</sup></font>实现。

T<sub>warmup</sub>:=1.5λ(1+1/n)/(1-5η)nρ   ,  T<sub>confirm</sub>：=O（λδ）

请注意，在上述定理中，T<sub>confirm</sub>参数是针对遭受攻击时的最坏情况交易记录的。在乐观的情况下，混合共识达到了O（δ）的交易确认时间。此外，虽然定理是根据网络的实际延迟δ来表示的，但实际上，我们必须预先确定δ的上限估计（表示为Δ）来参数化难题难度级别ρ。只要Δ确实是δ的上界，则安全性由上述定理保证，并且该方案实现响应性，即，交易确认时间不取决于上限Δ，而是取决于实际网络延迟δ。如前所述，如果我们选择较宽松的估计值Δ（即Δ的值较大），那么该方案将以更困难的难题进行参数化——一方面，这允许我们容忍更高比例的损坏节点;另一方面，敏捷性参数τ以及协议的预热时间将相应增加。

**备注1**（关于响应性的说明）。由于我们的方案是响应式的，因此我们为什么仍然需要关于Δ的先验知识，这是网络延迟的上限？特别是，我们可以简单地选择参数Δ为无穷大吗？ 仔细检查后，我们的敏捷参数τ和协议的预热时间T<sub>warmup</sub>都将取决于Δ。 如果我们选择一个更大的Δ，潜在的snail链会采用更难的谜题，因此容忍更多的腐败节点; 但另一方面，我们正在权衡敏捷性和协议的热身时间。

### 2.3其他相关工作
我们现在回顾其他相关工作。与最密切相关的工作进行比较，包括Decker<font color=#FF0000>[23]</font>和Byzcoin<font color=#FF0000>[37]</font>在前面有描述。

**扩展分散的共识。**
比特币的可扩展性和分散的、无许可的加密货币是一个非常明显的问题，并导致了社区的争论，有时还会引发激烈的争论。加密货币社区已经提出了各种各样的增量补丁，以在短期内缓解可扩展性压力，包括调整块大小等等<font color=#FF0000>[8，26，31，32，54]</font>。

Eyal等人提出了BitcoinNG<font color=#FF0000>[27]</font>，其中一个缓慢的snail链协议被用来在每个时代选出一个单独的领导者，而领导者负责在其任命期间合并和线性化交易。从本质上讲，BitcoinNG可以被视为流水线块传输，通过分解传输块传输——有效减少Nakamoto共识中最差延迟Δ的上界。BitcoinNG仍需要节点等待底层snailchain中的Θ（λ）块（在BitcoinNG中称为密钥块）才能稳定，以便在λ是安全参数的情况下确认事务。相比之下，混合共识是相应的，并且乐观情况下的交易确认时间仅为Θ（δ），其中δ是网络的实际延迟，而不是先验已知的上限Δ。BitcoinNG并没有对他们的协议给予正式的处理，但可以想象，他们的协议可以被证明实现了无许可的共识抽象。

Side链<font color=#FF0000>[9]</font>是解决比特币可扩展性问题的另一个显着特点。Side链的想法是支持主要比特币区块链的共识协议，并且Side链中的货币与比特币挂钩。 Side链协议缺乏形式上的保证，协议描述和实现仍然有些不完整。

近来已经提出了各种其他方法<font color=#FF0000>[11,38,49-52]</font>，以在具有不同信任假设的“分散”环境的不同变体中达成共识。

**许可的共识。**
在过去的30年里，社区对许可模式的共识协议进行了广泛的调查<font color=#FF0000>[14,15,21,25,29,35,39-41]</font>。这些工作通常考虑三种不同的模型：1）同步模型<font color=#FF0000>[24]</font>，其中的协议是在循环中进行的，并且在一个回合中交付的消息保证在下一轮开始时到达接收方;2）局部同步模型<font color=#FF0000>[25]</font>，其中网络有一个有界的延迟参数，但是协议不知道这个延迟;3）异步模型<font color=#FF0000>[14,15]</font>，网络的延迟可能是无限增长的。

我们的网络模型类似于局部同步模型的标准概念<font color=#FF0000>[25]</font>，但不是相同的。尽管我们允许协议在网络的延迟中知道一个先验的上界，但是我们的目标是实现响应性。我们强调，任何等待网络延迟并将延迟视为同步循环的协议都不能响应。如果协议确实等待网络延迟作为同步循环，那么这将真正转化为同步模型，然而，我们的响应需求使得协议的设计在我们的网络模型中是非常重要的。

早期关于许可共识的研究也考虑了重组。 例如，Vertical Paxos<font color=#FF0000>[40]</font>和BFT-SMART<font color=#FF0000>[12]</font>允许以动态方式重新配置节点。这些研究考虑了组重构的一个相关但有些不同的目的。调查这些技术是否可以适应我们的设置来执行委员会成员的切换会很有趣。然而，我们指出，早期的组重构技术并不能证明在选择性开放攻击下的安全性（事实上，大多数这些作品并未采用密码学上合理的推理框架）。 如果我们要适应这些技术，则需要一种新的密码合理的处理方法。

分布式系统和密码学。 共识和分布式系统与密码学密切相关，如多方计算（MPC）。一方面，多方计算（MPC）实质上依赖广播或分布式共识原语来实现潜在一致性并且活跃性，通常称为MPC环境中的保证输出。 另一方面，分布式共识协议通常使用密码来确保安全。例如，经过认证的拜占庭模型<font color=#FF0000>[24]</font>利用数字签名，密码学家将这种设置假设称为公钥基础设施<font color=#FF0000>[16,17,20]</font>。

另一方面，分布式系统中未经认证的拜占庭模型<font color=#FF0000>[41]</font>实际上被密码学家称为认证信道模型<font color=#FF0000>[16,17,20]</font>。 当协议采用计算安全的密码学原语时，我们隐含地假设网络的延迟必须在安全参数中被多项式约束（但可以是异步情况下的无限多项式），因为我们无法保证指数级增长协议的安全性。当分布式一致性协议使用计算安全基元时，最好的做法是依靠计算减少来证明协议的安全性——已经非常清楚地认识到，将密码系统建模为最自然的黑盒而没有仔细审查可能是错误的，容易出现和有缺陷<font color=#FF0000>[5-7,10,13,18,33,34,43,44]</font>。

我们的论文展示了这样一种方法，我们采用由密码学家开发的协议组合框架<font color=#FF0000>[16,17,20]</font>来推理分布式系统协议——我们证明这样做是必要的，特别是通过处理选择性开放攻击。如果我们没有采用正式的、加密的推理框架，这些问题很容易被忽视。

## 3 问题定义
**功能极其微不足道。** 本文中的所有安全故障都将以某种安全参数λ∈N的形式表示为（指数）强弱函数。 如果存在一些常数c<sub>0</sub>>0，c<sub>1</sub>，使得对所有λ∈N，negl（λ）exp（ - （c<sub>0</sub>λ+ c<sub>1</sub>）），我们说一个函数negl（⋅）是可以忽略不计的。 在本文的其余部分，我们只是简单地使用可忽略的术语，但它的所有用途可以被强烈忽略的自动替换。

### 3.1 形式模型
**执行模型。** 我们假设以下执行模型：

- *交互式图灵机。*
我们假设密码学文献中经常采用的标准交互式图灵机（ITM）模型<font color=#FF0000>[16,17,20]</font>（但是后面将解释为增加了工作量证明）。有一个潜在的全球时钟会随着时间而增加;每个时钟滴答被称为原子时间步。

节点可以在每个原子时间步执行无限多项式计算量，以及多项式地发送和接收许多消息。虽然本文没有明确指出，但节点接收来自环境Z的输入并将其输出发送到环境。

- *工作量证明。* 我们假设有一对随机预言（H，H.ver）。在每个原子时间步中，每个节点最多可以创建一个Horacle查询，就是一个无界（多项式）数的H.ver查询。如果存在多个区块链协议实例，我们假设每个协议实例都有自己独立的随机预言器。环境不能直接查询随机预言器，但可以通过对手的帮助查询随机预言器。

- *腐败。* 在任何时间点，环境Z都可以以任意方式与腐败节点进行通信。 这也意味着环境可以看到腐败节点的内部状态。腐败节点可以任意偏离规定的协议，即展现拜占庭故障。所有的腐败节点都由表示为A的概率多项式时间对手控制，并且对手可以看到腐败节点的内部状态。

对于诚实节点，环境不能观察其内部状态，但可以通过协议定义观察任何真实节点向环境输出的信息。关于腐败模式的细节将在后面介绍。

- *网络交付。* 对手负责在节点之间传递消息。我们假设对手可以延迟或重新排序消息，可能会受到如下所述的某些限制。

**τ-敏捷腐败。**
在标准的自适应腐败模型中，只要环境希望破坏节点，腐败就会立即发生。 我们的协议在稍微宽松的自适应腐败模型下被证明是安全的，我们称之为τ-敏捷腐败。粗略地说，τ敏捷腐败认为，环境实际上只需要很短的时间就会腐蚀一个节点。更正式地说，根据以下程序，允许环境破坏并产生新的节点：

- *延迟腐败。* 我们假设环境可以自适应地破坏一个节点，但有以下限制。为了破坏节点i，环境必须在t表示的某个时间点向节点i发出“目标损坏”指令。节点i不会立即变坏，而是保持诚实，直到t +τ，并且在t +τ时刻变得腐败——此时，腐败节点i与环境任意通信并且可以随意与协议偏离。
- *杀死一个腐败的节点。* 一旦节点实际上变得腐败，环境就可以发出“杀死”指令来终止节点。 被杀的节点不再活着。环境不能直接杀死诚实的节点而首先不会让它们被腐败。
- *产生新的节点。* 环境也被允许产生新的节点，无论是诚实的还是腐败的节点。 在时间t<sub>spawn</sub>产生的节点在t<sub>spawn</sub>时间被认为是活的。 产生腐败节点相当于增加立即发生的攻击者的散列能力。 如果产生了一个诚实的节点，如果它希望稍后损坏该节点，则环境必须遵循延迟腐败程序。一个诚实的，新产生的节点开始运行主协议。

我们说一个节点（已经生成并且没有被杀死）可以有三个互斥的状态：

1.完整：一个没有收到“目标损坏”指令的诚实节点。

2.腐败前：一个诚实的节点已经收到了“目标腐败”指令，但尚未破坏。

3.腐败：一个节点可能会被腐化或产生诚实，但接收到“目标腐败”指令并且实际上已经腐败。

完整节点和预腐败节点都被认为是诚实的。

从此以后，每当我们说“一个诚实的节点在时间t执行某些动作”，我们就意味着节点i在时间t是诚实的。例如，如果我们说一个诚实的节点在t时刻向环境Z输出一条消息，我们隐含地意味着该节点在t时刻是诚实的（但可能会在以后变得腐败）。另外，如果我们说一个诚实的节点执行一个动作，这意味着该节点在执行动作的时候是诚实的，尽管它在将来可能会变坏。

**完全自适应的腐败和静态腐败。** 我们注意到0-敏捷腐败相当于完全自适应的腐败模型，其中环境Z可以立即破坏节点。在完全自适应的腐败模型下，一个节点是完整的，如果它是诚实的。

我们还在无许可模型中定义了静态腐败——静态腐败是一种较弱的腐败模型，只用于证明我们的下界——注意，假设一个较弱的腐败模型会产生更强的下界。我们假设在静态腐败模型中，环境可以在任何时候产生诚实或腐败的节点。然而，一旦一个诚实的节点被派生出来，环境就不能在以后破坏它。

**八卦网络模型。** 我们假设诚实节点发送的所有消息都分布在八卦网络上，并最终可以被所有其他诚实节点听到。对于在T时刻加入的节点，它将在时间T之后接收到诚实节点发送的所有消息。诚实的节点不需要知道网络中的其他节点的身份就可以向所有其他节点闲聊消息。

攻击者不能通过诚实的节点丢弃或修改消息，但可以重新排序或延迟受到某些限制的消息。敌手可以选择性地将消息传递给子集，但不是所有的诚实节点。

我们假设消息发送者的身份是未知的。消息可以被签名，但是一个诚实的节点并不知道公钥与节点的物理身份之间的对应关系。

我们定义了以下类型的八卦网络，它们对对手延迟和重新排序消息的能力施加了不同的限制：

- 同步模型。在同步模型中，在时间t中由一个诚实节点进行的消息被保证会到达所有诚实的节点，可能是出于顺序，在时间t+1中。此外，历史消息会立即传送到新生成的节点。
- δ-部分同步模型。在一个δ-部分同步模型中，时间t处诚实节点所传递的消息被保证在t+δ时刻到达所有诚实节点，可能是无序的。 而且，历史消息会立即传递给新产生的节点。

更正式地说，假设一个诚实的节点在时间t≤t*
闲聊一个消息，那么如果一个节点i在时间步t*+δ中诚实，那么它肯定收到了这个消息。

注意，在实践中，诚实节点可以实现历史记录检索服务——这样，节点就可以在生成共识实例时获得整个历史记录的副本。不难看出，如果任何一个诚实的节点保持诚实并至少在3δ时间内生存，则不会丢失历史记录。

正如后面的3.2节所述，我们允许我们的协议知道网络延迟上的一个可能松散的上界Δ，因为底层的snai链必须知道这个上界，以便对挖掘难度进行参数化。但是，我们要求协议是有响应的，即它的实际性能必须仅取决于网络的实际δ值，而不是松散的上限Δ。

**随机协议执行和概率空间。** 设Π为某协议，令A，Z为概率多项式时间（或简称p.p.t）算法，令λ∈N。令exec[Π]（A，Z，λ）为一个随机变量，表示全部联合视图节点（即，他们的所有输入，随机硬币和接收到的消息，包括来自随机预言的消息）。

让属性成为一个函数，它把一个固定的视图作为输入，并输出0或者1。在整篇论文中，每当我们说概率为p的exec[Π]（A，Z，λ）时，我们正式表示为

Pr[hview← exec[Π](A, Z,λ):property(view) = 1]= p

其中概率被用于A，Z，所有诚实节点的所有 机硬币以及所有随机的预言。

**符合执行。** 我们经常对敌手A和Z施加约束来证明协议的安全属性。因此，我们根据对（A，Z）的约束条件来定义我们认为合规执行的内容。

**定义1**
（（n，δ，τ）-有效（A，Z））。我们说对（A，Z）是（n，δ，τ） - 有效的w.r.t. 协议Π如果A和Z是概率多项式时间算法，那么对于每个λ∈N，对于exec[Π]（A，Z，λ），以下概率为1：

1.在任何时间点，活节点数<font color=#FF0000><sup>6</sup></font>是n;

2.来自诚实节点的延迟消息至多在δ个时间步骤中;

3.一旦诚实的节点接收到来自环境的输入“目标损坏”，则在节点损坏前至少需要τ时间。

定义2（（n，α，δ，τ）- 有效的（A，Z））。 我们说对（A，Z）是（n，α，δ，τ）-有效的w.r.t.）-根据定义1有效，而且，对于任何λ∈N，在任何支持exec [Π]（A，Z，λ）,它认为,在任何时候,不超过α的一部分节点生活在腐败或腐败前状态。

在整篇论文中，尽管没有明确指出，包括n，α， 和τ在内的所有参数都是安全参数λ中的函数。 此外，为了符号简单，在本文中，我们没有明确定义事务输入的有效性规则。然而，扩展我们的定义以纳入交易有效性规则并不难，例如Garay等人。<font color=#FF0000><sup>[30]</sup></font>和PASS等人<font color=#FF0000><sup>[47]</sup></font>。

我们的协议在选择包括满足特定约束的n，α，δ和τ参数可能是安全的。因此，我们定义了Γ可容许性的概念，其中Γ是对参数选择施加约束的函数。

定义3（Γ-可接受）。Γ是参数n，α，δ，τ中的二元函数。 我们说这是一个p.p.t.对（A，Z）是Γ可容许的w.r.t.一些协议Π如果存在n，δ>0且α，τ≥0使得

- Γ（n，α，δ，τ）= 1;
- 按定义2的（A，Z）是（n，α，δ，τ） - 有效的w.r.t. Π;

### 3.2 问题定义：无许可共识
我们的混合共识协议在无许可模型中实现了状态机复制抽象，因此我们将这种抽象称为无许可的共识。在一个无许可的共识协议中，节点在一段时间内保持一个日志，这是一个事务列表;而且，一致性和活力是有保证的。我们的无许可共识抽象是Garay等人<font color=#FF0000><sup>[30]</sup></font>和PASS等人<font color=#FF0000><sup>[47]</sup></font>所采用的“公共分类”抽象的一种变体。差异是不重要的。特别地，我们本质上将事务内存池合并到我们的抽象中，这样维护事务内存池就不会留给调用者了。相比之下Garay等人<font color=#FF0000><sup>[30]</sup></font>和PASS等人<font color=#FF0000><sup>[47]</sup></font>的公共分类抽象将其留给调用者来维护一个交易内存池。

更正式地说，无许可的共识满足以下抽象。

**输入和输出。** 环境Z可以在每个时间步骤向每个诚实节点输入一组事务TXs。在每个时间步中，一个诚实的节点向环境Z输出一个完全有序的事务日志（可能是空的）。

**安全性定义。**让p.p.t.算法（A，Z）为（n，α，δ，τ） -有效的w.r.t.一个无权限的共识协议Π。 让Twarmup，Tconfirm，Tbootstrap成为λ，n，α，δ和Δ中的多项式函数。我们说一个没有权限的共识协议Π是安全的w.r.t.（A，Z）的参数（T<sub>warmup</sub>，T<sub>confirm</sub>，T<sub>bootstrap</sub>），如果存在一个可忽略的函数negl，那么对于每个λ∈N，具有1-negl（λ）概率，下列属性适用于exec [Π]（A，Z，λ）：

- 一致性：一致性包括以下属性：

-通用前缀。 假设一个诚实的节点i在时间t输出LOG到Z，而一个诚实的节点j（相同或不同）在时间t'输出LOG'到Z，它认为要么LOG'≺LOG或LOG≺LOG'。 这里的关系≺表示“是前缀”。按照惯例，我们假设对于任何x，∅ ≺ x和x ≺ x。

-自洽。 假设一个节点i在t时刻诚实并且t'≥t，并分别在t和t0时刻输出LOG和LOG，它认为LOG≺LOG'。

- 活力：假设环境Z在时间t≥T<sub>warmup</sub>时将TXs输入到一个诚实的节点。假设我在t<sub>spawn</sub>时产生了一些节点，并保持诚实直到t'≥max（t<sub>spawn</sub>+T<sub>bootstrap</sub>; t + T<sub>confirm</sub>）。令LOG成为节点i在时间t'的输出，它认为任何tx∈TXs都s包含在LOG中。

直观地说，活跃度表示在T<sub>confirm</sub>时间内，输入到诚实节点的交易被包含在他们的LOG中。此外，T<sub>warmup</sub>被称为协议的预热时间。

请注意，上述定义是关于特定（A，Z）对的。然而，我们后面的主要定理将阐述任何p.p.t的混合共识协议的安全性。（A，Z），只要他们尊重某些约束。

**备注2.**
对于我们的混合共识协议，T<sub>bootstrap</sub>=0，即新产生的节点立即自举。因此，我们经常省略编写术语T<sub>bootstrap</sub>=0而没有歧义的风险。然而，我们的问题定义允许多项式T<sub>bootstrap</sub>，因为这将允许我们证明更强的下界。

响应性。 我们说，如果活性参数T<sub>confirm</sub>仅取决于网络的实际δ，而不是用于参数化协议的松散上限Δ，那么无许可的一致性协议是响应。

## 4 构建块
### 4.1 底层区块链协议
我们的主要方案是效率自举，我们从一个潜在的低速区块链引导，表示为snail链，以获得一个快速交易确认和高吞吐量的无许可共识协议。

我们假设底层的低速共识协议表示snail链（例如，比特币的Nakamoto协议<font color=#FF0000><sup>[46]</sup></font>）实现了一个区块链“抽象”，它可以被看作是在第3.2节中定义的一个特殊的无许可共识协议。

**抽象。** 我们假设snailchain协议提供以下输入/输出抽象。

输入。 在每个时间步骤中，环境Z输入到每个诚实节点（recs，pk），其中recs表示一组记录，并且pk表示公钥。

输出。 在每个时间步骤中，诚实节点向环境输出以下内容：

chain := {(recs<sub>i</sub>,pk<sub>i</sub>)}<sub>i</sub>

**有用的概念。** 我们定义了以后会有用的以下概念。
本地链。 在每个时间步中，一个诚实的节点向环境输出一些链，为了简单起见，我们在这个时间步中将此链称为诚实节点的本地链。

完整和诚实的块。给定链表示在某个时间t一个诚实的节点的本地链，我们可以定义链中的每个块对链的前缀而言是否完整（或诚实地对待）。一个块链[j]：=（recs，pk）据说是完整的（或诚实的对应）w.r.t.一个前缀链[：j']，其中j'<j如果在某个时刻t'≤t存在某个节点i完整（或诚实的响应），则1）节点i在时间t输出链'到Z'那链[：j']≺chain'，和2）在时间t'+1处Z节点输入（recs，pk）到节点I.非正式地，对于一个诚实的聚会链表示链，块B：=链[j]是完整的（或诚实的对应） 一个前缀链[：j']，其中j'<j，如果早些时候有一些诚实的节点在其本地链包含前缀链[：j']时接收到块B作为输入。

**安全性定义。** 与早期的工作<font color=#FF0000><sup>[27,30,36,47]</sup></font>类似，我们为snailchain协议定义以下属性。 在以下所有中，概率是根据所有诚实节点，环境Z以及执行中的对手A所消耗的随机性来定义的。

假设（A，Z）是（n，α，δ，τ）-有效的w.r.t.snail链。 令WC，WQ，WG为λ中的多项式函数。 设Q，G，G'为λ，n，α，δ和Δ中的多项式函数。 我们说snailchain协议满足WC-一致性，（WQ，Q）链质量和（WG，G，G'）链增长w.r.t.到（A，Z），如果存在一个可忽略的函数negl，使得对于任何λ∈N，除了negl（λ）失败概率，以下属性适用于exec [snailchain]（A，Z，λ）：

- 一致性。 对于在t时刻诚实的任何节点i以及在t时刻t诚实的任何j（相同或不同），让chain表示在时间t我输出到Z的节点，并让chain'表示什么节点 j在时间t'输出到Z，它保证：

chain[: −W<sub>c</sub>] ≺ chain'

- 链质量。 让chain表示在任何时间t一个诚实的节点输出到Z的东西。那么对于任何λ1≥W<sub>Q</sub>（λ），如果|chain|≥λ<sub>1</sub>，它认为对于任何i≤|chain|-λ<sub>1</sub>，chain[i：i+λ<sub>1</sub>]中至少[Qλ<sub>1</sub>]个块的数目是完整的。chain[：i-1]。换句话说，在任何时候，在一个诚实节点的输出链中任何λ<sub>1</sub>≥W<sub>Q</sub>（λ）个连续的块窗口中，至少Q个块的块率是完整的w.r.t.窗口的前缀。

链增长。 在每个时间步骤中，以下属性都成立：
1.一致的长度。假设一个诚实节点在时间t输出链。 它在任何t'≥t+δ时任何诚实节点都必须至少输出一个|chain|长 。

2.链增长。 假设一个诚实的节点i在时间t输出chain，一个诚实的节点j（相同或不同）在时间t'≥t输出chain'，假设G·（t'-t）≥G<sub>W</sub>（λ） ·（t' - t）≤| chain'| - | chain | ≤G'·（t'-t）。

因此，直观地说，链增长1）诚实的节点具有大致相同的链长，2）诚实节点的链不能生长得太慢。

为了方便起见，我们现在定义一个名为活跃度的派生属性。如果我在t时刻是一个诚实的节点，让（recs<sup>t</sup><sub>i</sub>,_）表示在t时刻环境Z向诚实节点i输入的内容。 让rec记录一下。我们说，如果rec∈recst<sup>t</sup><sub>i</sub>，则Z在时间t推荐rec到节点i。

我们说snail链协议满足活跃w.r.t.（A，Z）的存在性参数T<sub>snail</sub>，如果存在一个可忽略的函数negl，使得对于任何λ∈N，具有1-negl（λ）概率，以下为exec[snailchain]（A，Z，λ）：

- *活跃度。* 让rec记录一下。如果对于每个诚实节点i，对于每个t'= t，t+1，.....环境Z建议rec，除非rec已经包含在节点i的output<sup>8</sup>chain[：-λ]中，那么我们在时间任何t<sub>1</sub>≥t+T<sub>snail</sub>，如果一个诚实的节点输出chain'，则rec必须包含在chain'[：-λ]中。

直观地说，活跃度只是说，如果环境Z继续向T<sub>snail</sub>时间内的所有诚实节点输入相同的记录rec，则在最多T<sub>snail</sub>时间rec将包含在所有诚实节点的本地链中。

**引理1 **
（活跃度为派生财产）。 对于任何p.p.t. 算法A，Z，任何Q>0;如果snail链满足WC-一致性，（W<sub>Q</sub>,Q）链质量，则所有λ的WC（λ）+W<sub>Q</sub>（λ）+λ≥W<sub>G</sub>（λ）的任何W<sub>C</sub>，W<sub>Q</sub>， 和（W<sub>G</sub>，G，G'）- 链增长 （A，Z），然后snail链满足活泼w.r.t. （A，Z），其活性参数T<sub>snail</sub>=（W<sub>c</sub> + W<sub>Q</sub> +λ）= G。

请注意，为了方便以后的应用，我们定义了一个略有修改的活性版本，与Garay等人<font color=#FF0000><sup>[30]</sup></font>和PASS等人<font color=#FF0000><sup>[47]</sup></font>和Fruit链 <font color=#FF0000><sup>[48]</sup></font>比较。 直观地看到，我们的活性概念是PASS等人<font color=#FF0000><sup>[47]</sup></font>和Fruit链<font color=#FF0000><sup>[48]</sup></font>所采用的。

底层的snail链是一个无响应的无许可的共识。 不难看出，我们在4.1节中定义的基础snail链抽象可以被看作是一个“无许可共识”协议的特例实例。 尤其是，每个节点的LOG可以是chian[：-λ]中的有序记录列表。由于我们需要在典型参数下将期望块间隔设置为Θ（Δ），其中Δ是网络延迟的先验上限，所以这种无许可的一致性协议是无响应的。 因此T<sub>confirm</sub>：=Θ（λΔ）。

#### 4.1.1 Nakamoto作为潜在的snail链
Garay等人<font color=#FF0000><sup>[30]</sup></font>证明Nakamoto共识<font color=#FF0000><sup>[46]</sup></font>假定完全同步模型满足上述性质的变体，即消息是即时传递的并且不能被敌手推迟。 Pass等人<font color=#FF0000><sup>[47]</sup></font>加强这些性质并证明Nakamoto共识在δ的适当条件下在δ-部分同步网络中满足它们。

下面我们重申Pass等人<font color=#FF0000><sup>[47]</sup></font>关于潜在的snail链的主定理。设α和β分别表示α+β=1的腐败节点和诚实节点的比例，设ρ表示单个节点在一个时间步中挖掘一个有效块的概率。ρ与采矿难度参数密切相关。

- 设p = 1 -（1-ρ）βn表示某个诚实节点在单个时间步中挖掘块的概率。
- 令q：=αnρ表示对手可以在单个时间步中挖掘的期望块数的上限。
- 令γ：=p/ 1+δp可以认为是由网络延迟δ折现的p的一个版本。

**定义4**
（snail链Γ<sup>snail</sup><sub>ρ</sub>的允许参数）。如果满足以下条件，我们定义Γ<sup>snail</sup><sub>ρ</sub>（n,α,δ,τ）= 1。

- n> 0，δ> 0，τ≥0都是λ中的多项式函数;α>0是常数;
- 存在一个常数η>0，使得p（1-（2δ+2）p）≥（1 +η）q。

**定理4**
（Nakamoto作为潜在的snailchain<font color=#FF0000><sup>[47]</sup></font>）。 对于任何常数η0，η1，η2，η，ρ> 0，假设Q = 1-（1+η<sub>0</sub>）q /γ，令G =γ/（1+η<sub>1</sub>），令G<sub>0</sub> =（1+η<sub>2</sub>）Nakamoto一致性协议<font color=#FF0000><sup>[46][47]</sup></font>（以下简称snail链）参数化为挖掘难度参数ρ满足ηλ一致性，（ηλ,Q）链质量和（ηλ，G，G'）链增长wrt 任何p.p.t.（A，Z），即Γ<sup>snail</sup><sub>ρ</sub>- 可接受的w.r.t.snail链。

**典型的参数化。** 通常在实践中，我们将设置难题的难度参数ρ：=Θ（1 /Δn），其中Δ是网络延迟δ的先验已知上限。 在这种典型的参数化下，我们需要大约3/4的整体诚实来确保大约2/3链的质量。

**推论1**
（Nakamoto<font color=#FF0000><sup>[46][47]</sup></font>作为潜在的snail链）。对任何（任意小的）常数ε> 0，令α= 1/4-ε，那么对于每一个n，δ存在足够小的ρ<sub>0</sub>：=Θ（1 /δn），使得对于任何常数η>0，η'> 0，Nakamoto的采矿难度参数ρ<ρ<sub>0</sub>的协议满足η0λ-一致性， （n'λ，Q）链质量和（η'λ，G'，G'）链增长关系中任何Γ<sup>snail</sup><sub>ρ</sub>-可容许的（A，Z）其中

Q > 2/3, G = 3/4nρ, G' = (1 + η)nρ

或者更简单地（非正式地）提出，对于任意小的常数ε> 0的每个α=1/4-ε，存在实现Q>2/3链质量的适当参数化的Nakamoto共识协议。

#### 4.1.2 Fruit链作为潜在的snail链
使用Nakamoto作为潜在的snail链的问题是链条质量损失。 由于自私的采矿攻击，中本要求3/4以上的诚实才能达到2/3的链质量，这对于民选委员会来说是2/3的诚实。由于混合共识采用模块化方法，因此我们可以使用替代方案Fruit链<font color=#FF0000><sup>[48]</sup></font>协议来实现（几乎）与Nakamoto相同的正式抽象。

在高层次上，Fruit链协议在底层运行了一个Nakamoto共识;然而，矿工们在寻找块时同时开采Fruit。 Fruit包含交易，底层Nakamoto区块链中的块包含成果（但不包括交易）。在Fruit链协议中，Fruit被视为新块，并被视为区块链抽象的一部分，但潜在的Nakamoto可被视为协议的内部细节，不需要暴露于外部。我们将假定Fruit链协议将以下参数作为输入参数（请参阅Fruit链论文的详细信息<font color=#FF0000><sup>[48]</sup></font>）：

- 开采难度参数ρ和ρf，分别用于开采块和Fruit。 今后我们将假设ρf：=ρ是硬编码的（尽管任何常数c≥1的ρf：=cρ也应该起作用），因此我们不再明确提及ρf。
- 回顾参数κ，即区块链悬挂Fruit的距离;
- 新近度参数R，即一个Fruit被悬挂在底层区块链中的（R·κ）-recent区块时被认为是新鲜的。 今后，我们将简单地假设R：=17是硬编码的（尽管任何其他大于1的常数也应该起作用），因此我们在今后不再明确提及新近度参数<font color=#FF0000><sup>9</sup></font>。

**定理5**
（Fruit链作为潜在的snail链<font color=#FF0000><sup>[48]</sup></font>）。 （1-α）nρ，G'=（1+5η）nρ，Q=（1-5η）（1-α） ，用（ρ，κ=λ/34）参数化的Fruit链协议<font color=#FF0000><sup>[48]</sup></font>满足λ一致性，（λ/η，Q）-fruit品质，（λ/η，G，G'） - fruit生长任何p.p.t.（A，Z）即是可接受的w.r.t.snail链。

**推论2**
（Fruit链作为潜在的snail链<font color=#FF0000><sup>[48]</sup></font>）。 对于任意（任意小）常数>0，假设α=1/3-ε，存在合适的κ=Θ（λ）和常数0<η<1（与ε相关）此外，对于每个n，δ>0，存在足够小的ρ：=Θ（1/δn），使得具有参数（ρ，κ）的Fruit链满足λ-一致性，（λ/η，Q）链质量和 （λ/η，G，G'） - 链增长 任何Γ<sup>snail</sup><sub>ρ</sub>-可容许的（A，Z）其中

Q > 2/3, G = 2/3nρ, G' = (1 + 5η)nρ

或者更简单（非正式地），对于每个α=1/3-ε，其中ε> 0是一个任意小的常数，有一个适当的参数化的Fruit链协议，可以实现Q> 2/3链质量。

### 4.2 强安全许可的拜占庭式容错
我们将依赖于一个许可的共识协议。众所周知，如何在部分同步网络中构建拜占庭式容错（BFT）协议<font color=#FF0000>[21、25、42]</font>;而且，这些协议实现了响应性。

由于与选择性开放式攻击相关的技术细节，我们需要为我们的BFT构建块定义一个更强的安全概念，而不是最自然的基于属性的概念。我们考虑使黑箱使用签名算法的BFT协议。设Σ：=（Gen，Sign，Verify）表示签名方案。我们使用符号BFT<sup>Σ</sup>表示协议BFT由签名方案Σ进行参数化。此外，我们要求BFT仅使用黑箱来使用Σ：Gen和Σ：Sign函数 ——在下面的表达式中，BFT节点查询将提供Σ：Gen和Σ：Sign oracles的环境Z.在形式上，我们假设通过签名方案Σ：=（Gen，Sign，Verify）参数化的BFT<sup>Σ</sup>协议实现了以下抽象。

**输入。** 允许环境向诚实节点发送以下输入。 所有其他输入都被忽略。
- 环境Z可以将start（pki，comm）一次发送给一个诚实的节点i。
- 如果已经输入了开始命令，则环境Z可以在每个时间步骤将一组事务TXs输入到诚实的节点。
- 签名（msg）查询的答案。

**输出。** 诚实的节点随着时间的推移输出以下项目到Z.
- 如果输入了开始命令，一个诚实的节点将在每个时间步中向Z输出一个完全有序的日志记录。
- 如果输入了一个开始命令，一个诚实的节点可以输出到Z形式的查询（msg），其中msg∈{0,1} *表示一个消息。

**符合执行。** 我们考虑在一个部分同步的网络中执行一个BFT协议，其中有一些静态损坏，详见下文。环境Z和敌手A也必须满足一定的限制条件。设T<sub>stamp</sub>是λ，n，Q和δ中的一个多项式有界函数。如果一对概率多项式时间算法（A，Z）被认为是（n，Q，δ，τ，T<sub>stamp</sub>） - 有效的w.r.t. BFT则以下成立：

- 根据定义1（A，Z）是（n，δ，τ） - 有效的w.r.t. BFT。
- 有点静态腐败。必须在T<sub>stamp</sub>之前声明所有“产卵”和“目标损坏”指令，其中Tstart表示启动命令首先通过Z输入到诚实节点的时间。
- 委员会协议。如果诚实的节点i在时间t接收到来自Z的输入start（pk<sub>i</sub>，comm），并且诚实的节点j在时间t'接收到输入start（pk<sub>j</sub>，comm'），则认为comm = comm'。此外，如果i≠j，则pk<sub>i</sub>≠pk<sub>j</sub>。
- 关闭开始。让T<sub>stamp</sub>是一个诚实节点接收输入start（-;-）的最早时间。那么，对于任何在T<sub>stampt</sub>t+δ时刻我都诚实的节点，我必须通过时间T<sub>stamp</sub> +δ接收输入start（-;-）。诚实时，每个节点最多接收一次启动。
- 弹性。至少必须在开始命令中指定pki∈comm的[d]Q·|comm|]数，这些命令输入到T<sub>stamp</sub>之前保持诚实的节点。
- 签名oracle的正确性。对于输入到诚实节点的任何开始（pki;_）命令，pki必须在签名方案Σ的有效公钥的范围内。

在诚实节点i的任何符号（msg）查询中，Z立即返回一个答案σ，使得Σ：Verify（pki，msg，σ）=1。

**安全性定义。** 令T<sub>stamp</sub>，T<sub>bft</sub>为λ，n，Q和δ中的多项式有界函数。假设（A，Z）是（n，Q，δ，τ，T<sub>stamp</sub>）-有效的w.r.t.BFT。那么，对于支持exec[BFT]（A，Z，λ）的任何视图，如果以下属性成立，那么我们说安全性T<sub>bft</sub>（view）= 1。

- 一致性。 一致性包含以下属性：

——公共前缀。如果一个诚实的节点i在任何时间t<T<sub>stamp</sub>输出log，并且诚实的节点j（相同或不同）在任何时间t'<T<sub>stamp</sub>输出log'，它就认为要么是log≺log'或是log'≺log。

——前后一致。假设一个诚实的节点i分别在时间t和t'输出log和log'，使得t<t'<Tstamp，它必须保存log≺log'。

——活跃度。 如果Z在时间T<sub>start</sub>≤t<T<sub>stamp</sub>-T<sub>bft</sub>时将TXs输入到一个诚实的节点，那么任何在时间t'= t + T<sub>bft</sub>处诚实的节点都将在时间t'输出一个log，使得TXs≈log。T<sub>bft</sub>被称为活性参数。

**定义5**（强安全的BFT协议）。 设T<sub>bft</sub>是λ，n，Q和δ中的一个正多项式。 对于任何p.p.t，我们说协议BFT对于任意n，δ> 0，τ≥0，任意正多项式T<sub>stamp</sub>的活性参数T<sub>bft</sub>都具有很强的安全性以防止（1-Q）损坏。A和任何多项式g，都存在一个p.p.t. 对手B和多项式g'，因此对于任何p.p.t. Z使得对于任何λ∈N，（A，Z）是（n，Q，δ，τ，T<sub>stamp</sub>） - 有效的w.r.t. BFT。

Pr [view←exec[BFT](A,Z,λ):secure<sup>T<sub>bft</sub></sup>(view)≠1] ≥ g(λ)
⇒  Pr [view←exec[BFT](B,Z;,λ):forgery(view) = 1] ≥ g'(λ)

在伪造（视图）= 1的情况下，如果在视图中，
- 在某个时间t，敌手向环境Z输出一个伪造对（i，msg，σ），使得节点i在t时刻诚实;
- 到时间t，环境Z向节点i输入开始（pki ;-);
- Σ：验证（pki，msg，σ）= 1; 并且
- 在t时刻，节点i尚未将答案为σ的查询符号（msg）提交给Z.

**定义的微妙之处：**
BFT的腐败模型。我们的BFT构建块必须在“有点静态”的腐败模式下安全。我们现在详细阐述相关的定义细微之处。首先，在T<sub>start</sub>之前必须发布任何“产卵”或“目标损坏”指令，即当第一次启动输入到诚实节点时——在这个意义上，安全概念似乎“有点静态”。另一方面，由于以下原因，我们的安全概念比标准的“静态”安全概念更强大：对于在T<sub>start</sub>之前处于预先状态的节点，在BFT协议过程中它们可能在T<sub>stamp</sub>之前会损坏。重要的是，对于任何尚未损坏的节点，我们的所有安全属性（包括一致性和活跃度）必须在T<sub>stamp</sub>之前保留。相比之下，静态概念不需要将安全保证扩展到预先破坏的节点。事实上，我们不难发现，我们的“稍微静态”的安全概念严格地比标准的“静态”安全概念更强大，并且构建一个可能表现出这种分离的（可能是人为的）BFT协议并不困难。

**定义的微妙之处：BFT的强大安全性。**
我们认为，由于与敌对选择性开放攻击相关的技术细节，我们需要为BFT子协议定义上述更强的安全概念。下面我们将这个概念与最自然的基于财产的安全概念进行比较。

首先，尽管协议的大多数其他安全定义遵循最自然的基于属性的定义风格，但BFT构件块的上述安全性概念更强。特别是，如果BFT满足上述强大的安全性概念，那么一个自然的实例化，即诚实节点现在生成自己的签名密钥对并实现自己的签名预言，将满足最自然的基于财产的概念。当然，为了使描述完整，在这种情况下有效的环境Z将等待听到每个诚实的BFT节点i输出公钥pki，然后向所有诚实的节点输入开始（comm），其中comm包含足够多的诚实节点的公钥。

当诚实节点实现自己的密钥生成和签名oracles时，我们可以将诚实节点的密钥生成和签署oracle实现分组到Z'环境中。然后，这个特定的Z'永远不会泄露诚实节点各自的秘密签名密钥。因此，如果存在一些对手p.p.t.A，使得exec[BFT]（A，Z'，λ）以不可忽略的概率不符合任何这些性质，则我们可以构造一个对手B，使得在交互期间exec [BFT]（A，Z'，λ），B有效地破坏了签名方案的安全性。

其次，我们指出，基于自然属性的定义比较薄弱，不足以达到我们的目的。特别是在后面的混合共识协议中，用于BFT的环境Z可以选择性地打开一组公钥以包含在BFT协议的启动命令中。例如，人们可以很容易想象一个有点人为设计的BFT协议，这种协议在最自然的基于属性的定义下是安全的（就像本文中的所有其他定义一样），但是会容易受到选择性开放攻击的影响：想象一下，诚实的节点公开他们的秘密如果对所选公钥的某些谓词满意，则签署密钥——这个谓词可以很容易地被选择，使得它对于一个诚实生成的公开密钥集合只有negl（λ）概率满足，而不受对抗选择性开放的影响，但是满足对抗性选择性开放的压倒性属性（例如，如果所有公钥都用1结束）。

幸运的是，不难看出许多已知许可的BFT协议的实例满足了这种强大的安全性概念，例如PBFT<font color=#FF0000>[21]</font>具有数字签名。

**关于签署orcale的说明。**
我们注意到，或者，可以将签署orcale划分为采用GUC方法的全局签名功能<font color=#FF0000>[17]</font>。特别是，GUC是必要的，因为相同的签名方案由多个协议，内部BFT协议和我们的外部DailyBFT协议共享。如果我们采用GUC方法，那么我们的黑箱减少安全概念也可能更简单，因为我们不需要处理具有签名密钥的环境。另一方面，使用GUC可能会在符号方面引入其他复杂性。这两种方法基本上是通过重新划分算法边界来实现的。

**定理6**
（Castro和Liskov<font color=#FF0000>[21]</font>，在附录A中简要描述）。 存在一个BFT协议，对于活性参数Tbft：= O（nδ），腐败（1-Q）<1/3具有很强的安全性。
为了达到上述目的，我们可以修改PBFT的指数超时策略，使节点在每n次视图更改时加倍超时。为了完整起见，在附录A中，我们简要描述了PBFT协议，并且我们将读者引用到Castro和Liskov<font color=#FF0000>[21]</font>以获得进一步的细节和优化。请注意，稍后当我们将BFT用作混合共识中的子协议时，BFT节点n的数量将由csize：=λ替代。

## 5正式计划：Nakamoto的混合共识
### 5.1符号约定
**形式化框架的选择。** 我们使用广受欢迎的通用可组合<font color=#FF0000>[16,17,20]</font>框架来形式化和模块化地组成协议。为了展示我们的结构，我们将采用模块化方法。对于每个（子）协议，我们都正式描述其抽象——不是通过定义理想的功能，而是使用基于属性的方法。然后我们将展示如何编写这些子协议以最终构建我们的混合共识协议。

**会话标识符约定。** 对于任何协议prot，如果我们编写prot[sid]，那么sid（或方括号中的任何变量）表示协议实例的会话标识符。如果我们只在没有方括号的情况下编写prot，那么这意味着我们只关心协议的一个特定会话（尽管更高级别的协议可以调用多个会话），因此我们不明确指示会话标识符。

## 每日Offchain共识协议
对于模块化的协议组合，我们定义了一个称为每日offchain共识协议的中间抽象，即DailyBFT。在DailyBFT中，委员会成员运行一个offchain BFT实例来决定每日日志，而非成员则计算来自委员会成员的签名。

**DailyBFT概述。** DailyBFT中间抽象的定义通过以下方式扩展了BFT：

- 将安全性扩展到委员会非成员和后期产生节点。在定义层面上，DailyBFT定义扩展了BFT的定义，以包含委员会非成员。特别是，在下面的DailyBFT的正式定义中，所有的安全属性不仅必须由委员会成员来满足，也应该由委员会非成员来满足。此外，尽管BFT定义假设所有节点都是在T<sub>start</sub>之前产生的，但DailyBFT的定义允许节点稍后产生。因此，这里我们的安全定义包括一致性和活跃性适用于足够早产生的任何节点（委员会成员或非成员一致），即在截止日期T<sub>stamp</sub>之前。这些安全保证不会延伸到产生得太晚的节点，因为委员会成员在将来可能变得腐败，此时他们可以签署任意元组。正是由于这个原因，我们的混合共识协议（以DailyBFT作为构建块）需要明确处理后期产生，以便将安全保证延伸到晚产生的节点。
- 终止。 DailyBFT明确规定终止程序必须满足两个要求，即终止协议和及时终止。具体而言，允许环境Z向节点发送停止指令。及时终止要求BFT实例在诚实节点接收输入停止后迅速终止。终止协议要求所有诚实的节点在终止时达成相同的最终日志。
- 签署每日日志哈希。在DailyBFT中，委员会成员输出签署的每日日志哈希值，稍后将由混合共识协议消耗。这些签署的每日日志哈希满足完整性和不可伪造性。完整性表示，诚实的委员会成员输出正确签名的日志日志。不可伪造性说，除了正确的哈希之外，环境/攻击者不能伪造任何其他值的签名。

在形式上，假设一个DailyBFT[R]<sup>D</sup>协议，其中R是会话标识符（也称为日期），并且由分布D参数化，提供以下抽象。
**输入。** 在每个时间步骤中，环境Z可以多次提供以下类型的输入：1）keygen;2）start（comm）其中comm ={pki}<sub>i∈[m]</sub>3;）TXs;和4）停止。
 
**输出。** 诚实节点向Z输出以下类型的消息：

- 在输入keygen上，诚实节点输出pk←D。
- 在每个时间步t中，诚实节点输出notdone（log<sup>t</sup>）到环境Z，直到最后一步t*，它输出done（log<sup>t*</sup>，recs），其中recs是最终每日日志的哈希的∅或一组有符号的元组。完成后输出（log<sup>t*</sup>，recs），诚实节点在未来的时间步骤停止输出。

**术语。** 假设在支持exec[DailyBFT]（A，Z，λ）的特定视图中，环境Z向所有诚实节点输入一个唯一的开始（comm）命令——稍后我们的遵从性规则将要求这种情况，那么comm：={pk<sub>i</sub>3}i被称为选举委员会。

我们说，如果以下情况成立，节点i在时间t是诚实的委员会成员：
- 在第一次启动（comm）命令被输入到任何诚实节点之前，节点i输出到Z包含在comm中的pk。
- 节点i保持诚实，直到时间t（但可能会在后来腐败）。
 
从今往后，如果我们说“一个诚实的委员会成员，i在某些情况下执行一些行动或者是某种行为的接受者”，我们的意思是，在t时刻，i我是一个诚实的委员会成员。直到时间t，它仍然是诚实的，但以后可能会腐败。

诚实的委员会成员接受输入开始的最早时间表示为T<sub>start</sub>。T<sub>stop</sub>表示诚实委员会成员收到输入停止的最早时间。

我们说一个诚实的节点输出日志作为一个简写，意味着它输出done（log，-）或notdone（log）。

当一个诚实的节点我输出done（log，-）在某个时候，我们说日志是节点i的最后每日日志。

符合执行。 我们说一对（A，Z）是（n，Q，δ，τ，T<sub>stamp</sub>，T<sub>bft</sub>）-有效的w.r.t. DailyBFT，由定义1得如果（A，Z）不仅是（n，δ，τ）-有效的w.r.t.DailyBFT，但以下内容也成立：

- 委员会协议。如果诚实节点i在时间t接收到来自Z的输入开始（comm），并且诚实节点j在时间t'接收到来自Z的输入开始（comm'），则它认为comm = comm'。
- 关闭开始和停止。让T<sub>start</sub>是一个诚实节点接收输入start（-）的最早时间。那么，对于任何在T<sub>start</sub>+δ时刻i都是诚实的节点，i必须接受时间T<sub>start</sub>+δ的输入start（-）。同样，让T<sub>stop</sub>是一个诚实节点接收输入停止的最早时间。那么，对于任何节点，i真诚的在时间T<sub>stop</sub> +δ，i必须接受时间Tstop+δ的输入停止。对于任何在时间t接收到停止的诚实节点，它必须在t'<t时收到开始。
- 弹性。至少[Q·|comm|]数量的pki∈comm必须在输入到任何诚实节点的第一个开始命令之前，由保持诚实的节点输出，直到T<sub>stamp</sub>。
- 尽早停止。T<sub>stop</sub>+T<sub>bft</sub>+δ≤T<sub>stamp</sub>，其中T<sub>stop</sub>是最早的诚实委员会成员收到输入停止的时间。
- 临时静态损坏。对于任何pk∈com，如果pk由在T<sub>stamp</sub>之前变得腐败的节点输出，那么“目标损坏”指令必须在T<sub>start</sub>之前发出。

**安全性定义。**
如果任何n>0，δ>0，任何τ≥0，任何T<sub>stamp</sub>>0，则对于任何（A，Z），DailyBFT协议被认为是对于活性参数T<sub>bft</sub>的（1-Q）（n，Q，δ，τ，T<sub>stamp</sub>，T<sub>bft</sub>）-有效的wrtDailyBFT，存在一个可忽略的函数negl，使得对于每个λ∈N，除了negl（λ）概率外，以下属性适用于exec[DailyBFT]（A，Z，λ）：

- 及时终止。 时间终止包括以下内容：
-任何在T<sub>stop</sub>+T<sub>bft</sub>时刻诚实的委员会成员，必须按时间T<sub>stop</sub>+T<sub>bft</sub>输出done（log，-)。
-对于t时刻t诚实的任何节点，我们必须在t时刻输出done（log，-)。

在这两种情况下，当一个诚实的节点输出done（log，-)时，我们将日志称为节点的最终每日日志。

注意由于（A，Z）是（n，Q，δ，τ，T<sub>stamp</sub>，T<sub>bft</sub>） - 有效的w.r.t. DailyBFT，及时终止意味着以下内容：任何在T<sub>stamp</sub>之前产生并保持诚实的节点，直到T<sub>stamp</sub>必须通过T<sub>stamp</sub>输出done（-，-）。换句话说，如果任何节点在T<sub>stamp</sub>之前产生并且在诚实时输出done（ - ， -），则done（-，-）必须不晚于T<sub>stamp</sub>输出。

- 一致性。 一致性包括以下内容：

-自洽性。 对于在T<sub>stamp</sub>之前产生的任何节点，并且在时间t'处诚实，假设节点i在时间t≤t'处输出log并且在时间t输出log'，它认为log'≺log'。

-终止协议。对于在T<sub>stamp</sub>之前产生的任何节点i以及也在T<sub>stamp</sub>之前产生的任何节点j，假设节点i在它们损坏之前输出done（log'，-）和节点j输出done（log'，-），它认为log= log'。

-公共前缀。对于在T<sub>stamp</sub>之前产生的任何节点i，j，假设我在时间t是诚实的并且在时间t输出log，并且j在时间t'是诚实的并且在时间t'输出log，它认为 log ≺ log' 或者log' ≺ log。

请注意，似乎终止协议和自洽性暗示了公共前缀，但请记住，常见前缀必须另外适用于在变得腐败之前从未有机会输出done（-，-）的节点。

- 活跃度。 假设Z在T<sub>start</sub>≤t<T<sub>stop</sub>-T<sub>bft</sub>时输入TXs给诚实的委员会成员。那么，对于在t<sub>stawn</sub>≤t<sub>stamp</sub>时产生的任何诚实的节点i，如果i在t'≥t +T<sub>bft</sub>+δ时刻诚实，那么节点i必须在t*≤t'时刻具有输出log，以便TXs≈log。
- 完整性。 让comm是包含在开始命令输入到诚实节点的唯一集合。对于节点i输出的每一个pk∈ comm i都会在某个时刻t诚实，并且如果节点i在t时刻输出done（log，recs），那么它认为有效记录{R，hash（log）}<sub>pk-1</sub>∈recs其中的有效性是通过用pk进行正确的签名验证来定义的。
- 不可伪造性。 令t≤T<sub>stamp</sub>，让pk ∈ comm由t时刻诚实的节点i输出。然后，如果到时间t，攻击者A向环境Z输出有效元组{R，hash（log）}<sub>pk-1</sub>其中R是当前的DailyBFT实例的会话标识符，那么它必须保持节点i已经通过t完成了输出（log;-）并且h =hash（log）。

构建。 我们在图1中提供了来自BFT的DailyBFT协议的构建。下面是DailyBFT的操作的非正式描述：

- BFT虚拟节点和选择性开放委员会。DailyBFT节点通过键盘查询将新鲜的公钥输出到其环境中。 然后当它接收到一个start（comm）命令时，如果comm包含一个或多个自己的公钥，则该节点被选为委员会成员。在这种情况下，节点将为属于自己的通信中的每个公钥分配一个BFT虚拟节点。 在这里，委员会由环境通过start（comm）命令选择性地打开，稍后我们的证明需要利用BFT的强大安全性。

![avatar](https://github.com/truechain/wiki/blob/master/analysis/truechain-consensus-core/img/fan1.jpg)

图1：每日offchain线共识协议。 由于每个签名密钥都被重新用于内部BFT协议和外部DailyBFT协议，因此我们假设签名算法为内部BFT实例标记每个消息的前缀为“0”，每个消息为外部的DailyBFT，前缀为“1”来避免命名空间冲突。

![avatar](https://github.com/truechain/wiki/blob/master/analysis/truechain-consensus-core/img/fan2.jpg)

图2：混合共识协议的模块化组合。

![avatar](https://github.com/truechain/wiki/blob/master/analysis/truechain-consensus-core/img/fan3.jpg)

图3:mempool子协议跟踪事务，并在查询时，提出一组未完成的事务。为了简单起见，这里没有说明的一个明显的实用优化是，mempool可以清除已经在LOG中确认的事务。

- 会员和非会员基本操作。 委员会成员根据BFT协议填写每日日志，而非委员会成员通过对委员会成员签名来填充日志。
- 终止。节点执行终止程序如下：只要诚实的委员会成员收到停止指令，它就会向每个BFT虚拟节点输入一个特殊的签名停止事务。一旦内部BFT实例输出一个包含至少由[| comm|=3]不同的委员会公钥签名的停止事务的日志，日志就会被完成并输出。 在第一个[|comm|=3]停止交易之后的所有交易（具有不同的委员会公钥）将被忽略。
- 签署日常日志哈希。当委员会成员完成输出时，他们还输出了最终的每日日志的签名摘要——稍后，我们的混合共识协议将把这个摘要标记到snail链上。

**定理7**
（来自BFT的DailyBFT）。假设DailyBFT使用的签名方案Σ是安全的，并且该哈希是随机orcale。 假设BFT对于Q> 2/3的活性参数T<sub>bft</sub>'可以抵御（1-Q）的腐败。 然后，DailyBFT对于（1-Q） - 活性参数T<sub>bft</sub>：=T<sub>bft</sub>'+δ的腐败是安全的。

这个定理的证明被推迟到第8部分。

### 5.3 混合共识协议
我们现在描述我们的最终产品，即混合共识协议。混合共识消耗了DailyBFT的多个实例，其中轮流委员会就每日日志达成一致。混合共识主要做以下几点：

- 它使用snail链作为一种有效的方式来管理DailyBFT实例的生成和终止。在诚实节点之间提供弱同步的全局时钟;

![avatar](https://github.com/truechain/wiki/blob/master/analysis/truechain-consensus-core/img/fan4.jpg)

图4：主混合共识协议。一个新产生的，诚实的节点开始运行这个协议。我们假设历史是所有发送和接收的历史成绩单的集合。我们假设到子协议实例的消息路由是隐含的：每当任何子策略[sid]实例被分支时，历史[subprot [sid]]和与子策略[sid]有关的协议消息将自动路由到子策略[sid]实例。

- 回想一下，每个DailyBFT实例并不能确保产生太晚的节点的安全性，因为委员会成员在将来可能变得腐败很多，他们可以签署任意元组。 因此，混合共识引入了链上加戳机制，以便将安全保证延伸到即使晚点产生的节点。

图4是混合共识协议的算法描述。 图2显示了混合共识协议的模块组成。具体而言，混合共识协议在内部运行以下子协议实例：两个mempool实例分别表示为snailpool和txpool，一个snailchain实例和多个DailyBFT实例。我们现在更具体地解释这些子协议实例。

**交易mempools。**
混合共识协议维护mempools协议的两个实例（见图3），分别表示为txpool和snailpool。txpool是一个mempool，用于维护未完成的交易，并通过DailyBFT实例进行确认，并且该snailpool用于维护每日日志摘要在snailchain上加戳。mempool协议非常简单：只要环境输入新的事务，它就会在网络上闲聊交易。每当它听到来自网络的交易时，都会将它们保存在mempool中。

**snailchain。** 混合共识协议内部分叉了一个snail链实例。首先，snailchain用于达成委员会的协议，后者将运行offchain BFT共识。该委员会被选为csize的矿工：=λ连续的块。 潜在的snailchain链条质量属性确保足够多的这些矿工诚实的时间足够长。其次，这个snail链实例不是用于提交交易，而是用于标记每日日志摘要，以便该协议可以抵御追溯者在将来腐蚀委员会成员的追溯性腐败。

**DailyBFT实例。** 混合共识协议分散了DailyBFT协议的多个实例，我们使用索引R来表示每个实例的会话标识符。R也被称为日数，因此每个DailyBFT[R]实例输出“日志”。在每个DailyBFT实例中，当选的委员会成员依赖基础的BFT协议进行交易并输出每日日志，而委员会非成员计算来自委员会成员的签名来填充他们的日志。

**操作。**
每个节点都保留了过去所有记录的历史记录——我们假设这是为了形式化的简单性，并且可以在实践中对其进行优化。 新产生的节点立即获得历史记录（实际上，这可以通过具有诚实的节点提供历史检索服务来实例化）。

当一个新节点产生时，它会以如下方式填充它的日志：

- 匹配链上有效的元组。一个新生成的节点首先识别表单的所有链有效元组（R，h），其中R是日数，h是每日日志的哈希。然后，节点将搜索历史并识别与h一致的适当的每日日志logR。节点使用这些每日日志填充日志。这种链匹配过程有效地为新生成的节点提供了一种安全机制，以追踪并填充其输出日志的旧条目。

- 通过每日offchain的共识。 一旦这个追踪过程完成，节点将因此依赖于DailyBFT实例来进一步填充其输出LOG的剩余条目。在每个DailyBFT实例中，一个节点可以充当委员会非委员的委员会成员。

要做到这一点，一个节点会监视snail链实例的输出链。 一旦链长超过csize·R+λ，第R天开始，此时节点输入停止到先前的DailyBFT[R-1]实例（如果存在），并且输入start（MinersOf（chain[lower（R）：upper（R）]））到DailyBFT[R]实例。通常会有一段时间重叠，在此期间，DailyBFT[R-1]和DailyBFT[R]实例同时运行并输出其各自的日志。当节点将他们的日志记录吸收到最终的输出LOG中时，他们确保LOG始终保持连续而不留间隙。由于DailyBFT的及时终止财产，旧的DailyBFT [R - 1]将很快终止，此时新的DailyBFT [R]实例将完全接管。

### 5.4 定理陈述
定义6（混合共识Γ<sup>hc</sup><sub>ρ</sub>的容许参数）。假设T<sub>bft</sub>：=O（mδ）是具有m个节点的BFT的活性参数。如果以下成立，我们定义Γ<sup>hc</sup><sub>ρ</sub>（n，α，δ，τ）= 1：

- n> 0，δ> 0，τ≥0都是λ中的多项式函数。 α> 0是常数;
- 存在一个常数η> 0，使得p（1-（2δ+ 2）p）≥（1 +η）q（这是底层snail链安全所需要的）。
- 存在一个常数η<sub>0</sub>> 0，使得Q：= 1-（1 +η<sub>0</sub>）q /γ> 2/3。 （这是需要的，以便我们可以获得超过2/3链条质量的snail链。）
- 对于任何λ∈N，存在一个常数η1>0，使得G'：=（1+η<sub>1</sub>）nρ<λ/T<sub>bft</sub>δ。（这是必需的，因为这条链不会增长得太快而不能保证活力。）
- 对于一些适当的大常数c，存在一个常数η<sub>2</sub>>0，使得τ>4λ（1+η<sub>2</sub>）/γ+cλδ。（这是需要的，以便对手的灵活性受到足够的限制。）
 
在上面，参数p，q，γ是4.1节定义的n，α，δ中的函数。

**定理8**
（混合共识的主要定理）。 假设hash,H：{0,1}*→{0,1}λ是独立的随机序列，并且签名方案Σ是安全的。 那么，对于任何常数η>0，混合共识与Nakamoto实例做为snail链和采矿难度参数ρ是安全的活性参数（T<sub>warmup</sub>，T<sub>confirm</sub>）w.r.t. 任何p.p.t.Γ<sup>hc</sup><sub>ρ</sub>-可容许的（A，Z），其中

T<sub>warmup</sub> := 2λ(1 + η)/γ, T<sub>confirm</sub> := O(λδ)

请注意，上述T<sub>confirm</sub>参数适用于最差情况，在乐观情况下，混合共识达到的交易确认时间为O（δ）。
上述定理的证明将在第8节中介绍。

**典型的参数化。** 通常在实践中，如果我们将难题的难度参数ρ：=Θ（1/nΔ）设置得足够小，其中Δ是网络延迟上可能存在的先验已知的松散上限。 在这种参数化下，如果整体腐败率α大约为3/4，那么我们确保大约2/3的链质量。

**推论3**
（关于Nakamoto的混合共识的典型参数：定理的重述??）。假设对于任意常数ε> 0，α= 1/4-ε。那么对于每一个n，δ，存在足够小的ρ<sub>0</sub>：=Θ（1/δn），使得与Nakamoto的混合共识作为潜在的snail链，而且难度参数ρ<ρ<sub>0</sub>是安全的，w.r.t任何的p.p.t（n，α，δ，τ）-有效（A，Z）对于任何的τ以至于Γ<sup>hc</sup><sub>ρ</sub>（n，α，δ，τ）= 1，达到

T<sub>warmup</sub> := 8λ/3nρ, T<sub>confirm</sub> := O(λδ)

### 5.5 实际考虑和可能的优化

上面描述的方案为了简单起见进行了优化，并且有助于形式分析，但不适用于实际性能。有很多可能的优化。例如，与其让委员会成员逐一签署每笔交易，他们可以一次签署一批交易。在打印过程中，我们可以依靠阈值签名方案并将每日日志hash的单个签名印在snail链上，而不是让每个节点向snail链发送单独的签名。删除旧记录的存储也很容易。 我们将实际优化和实施留给未来的工作。

## 6 延伸：Fruit链作为潜在的snail链
Pass和Shi最近提出了一个名为Fruit链的新区块链协议<font color=#FF0000>[48]</font>。对于一个足够小的难题难度参数ρ：=Θ（1/nδ），对于任意小的常数ε>0，α：=1/3-ε，Fruitchain在任何足够大的窗口中获得Q> 2/3链质量连续的块。构建混合共识和Fruit链以获得响应性无共识协商一致性协议并不难，该协议对任意小的常数ε>0的1/3-ε整体腐败具有适应性。

Fruit链提供了与Nakamoto共识相同的正式抽象，但具有不同的参数。今后我们将使用术语“frtit质量”来表示Fruit链的链条质量，以及“fruit生长”来表示Fruit链的链条增长。在第4.1.2节和推论2所述的典型参数下，为了获得η-最优链条质量，Fruit链要求果实质量窗口相当大，即Θ（λ/η）。同样，fruit生长也需要时间窗口相当长。鉴于此，当我们将Fruit链作为底层snail链时，我们需要对第5节中描述的协议进行以下更改：

- 让混合共识<sup>λ，η</sup>用参数λ和η进行参数化。
- 重新定义csize：=λ/η，lower（R）：=（R-1）λ/η+1，和upper（R）：=R·λ/η。 换句话说，委员会尺寸设为λ/η，第R天开始协议等待链长|chain|≥upper（R）+λ。

**定义7**
（Fruit链上的混合共识一致性的允许参数Γ<sup>hcfruit</sup><sub>ρ，η</sub>）。 假设T<sub>bft</sub>：=O（mδ）是具有m个节点的BFT的活性参数。如果满足以下条件，我们定义Γ<sup>hcfruit</sup><sub>ρ，η</sub>（n，α，δ，τ）= 1。

-n> 0，δ>0，τ≥0都是λ中的多项式函数; α> 0是常数;
- 存在一个常数η'> 0，使得p（1-（2δ+ 2）p）≥（1+η'）q。（这是底层snail链安全所需的。）
- Q：=（1-5n）（1-α）>2/3。（这是需要的，以便我们可以获得超过2/3链条质量。）
- 对于任何λ∈N，G'：=（1+5η）nρ<λ/η（T<sub>bft</sub>+δ）。（这是必需的，因为这条链不会增长得太快而不能保证活力。）
- 对于一些适当的大常数c,τ>3λ（1 + 1 /η）/（（1-5η）（1-α）nρ）+cλδ。（这是需要的，以便对手的灵活性受到足够的限制。）

在上面，参数p，q，γ是4.1节定义的n，α，δ中的函数。

**定理9**
（关于Fruit链的混合共识：定理3的重述）。 对于任意（任意小）常数ε>0，令α= 1/3-ε，并且对于每个n，δ，存在足够小的ρ：=Θ（1/δn），合适的κ=Θ（λ） ，和常数η>0，使得具有参数（ρ，κ）的具有Fruit链的混合共识<sup>λ，η</sup>是安全的，有p.p.t.（n，α，δ，τ）= 1的任何合适的τ的有效（A，Z）有效值，使得Γ<sup>hcfruit</sup><sub>ρ，η</sub>（n，α，δ，τ）= 1，这里

T<sub>warmup</sub>:= 1:5λ(1 + 1/η
)=(1 − 5η)nρ, T<sub>confirm</sub> := O(λδ)

再次，上述T<sub>confirm</sub>=0（λδ）是最差情况下的交易确认时间（即使在受到攻击时）。乐观交易确认时间是O（δ），即独立于安全参数λ。

## 7 证明路线图
在给出详细的证明之前，我们首先描述一个帮助理解的高级路线图。为简单起见，我们将Nakamoto的混合共识作为我们描述的一个例子，因为除了不同的参数之外，关于Fruit链的混合共识的证明是一样的。

DailyBFT的混合共识。我们的证明将按照以下步骤进行。

1.首先，主要在引理2，引理3和事实4中，我们证明当作为混合共识的子协议执行时，DailyBFT的所有实例都具有绝对可能性的有效环境。一旦我们证明了这一点，我们就可以在以后的证明中依靠DailyBFT的安全属性。

2.接下来，我们证明了一对引理，它将T<sub>stamp</sub>（R）建立为每天R的“最后期限”。所有诚实的委员会成员的行为将在时间T<sub>stamp</sub>（R）完成并生效。引理4粗略地说，R日的所有诚实委员会成员都会在时间T<sub>stamp</sub>（R）上盖上正确签名的每日哈希给snail链。事实5大体上说，产生于T<sub>stamp</sub>（R）之后的节点不会创建DailyBFT（R）实例，但会依赖链上加盖的每日日志哈希值来决定第R日的日志。

3.建立T<sub>stamp</sub>（R）作为R日的最后期限，然后我们使用以下策略证明一致性（引理5和定理10）：

- 对于实际创建DailyBFT（R）实例的节点，我们知道它们必须在T<sub>stamp</sub>（R）之前产生。因此，我们依赖于DailyBFT（R）的属性来证明此类节点的一致性（委员会成员或非成员一致）。
- 对于没有生成DailyBFT（R）实例的节点，我们表明如果他们通过检查snail链上的内容来恢复其每日日志，他们也会满足一致性。直觉上，委员会成员总是在他们变得腐败之前在snail链上正确签署日志记录。因此，即使它们后来变得腐败，并因此可能会将任意东西压印到snail链上，它也为时已晚，因为诚实节点只会识别委员会成员公钥的第一个加盖日志哈希。

4. 最后，我们证明了混合共识的活跃性（定理11）大致如下。非正式地说，假设在R天（大致说来），环境将tx输入到一个诚实的节点。有两种情况：1）在R天足够早地提出tx，使得DailyBFT[R]实例的活性特性适用;和2）由于tx在非常接近于一天结束时关闭，所以提议tx太迟而不能被纳入R日志。在这种情况下，tx将被回滚到R+1天。直观地说，并且由于DailyBFT[R+1]的活跃特性，它也不会花费太长时间，将其合并到第R+1天的日志中。

但是，以上仅适用于实际生成DailyBFT [R]（或DailyBFT [R+1]）实例的节点。 对于任何加入太迟且没有生成DailyBFT [R]（或DailyBFT[R+1]）的节点，它将在处理历史记录产生后一天R的日志。现在，通过一致性属性，我们知道无论在什么日节点输出，它都会包含tx。

来自BFT的DailyBFT。这个证明的最技术部分涉及证明以下内容。请注意，当BFT作为DailyBFT内部的子协议运行时，BFT感知的环境由DailyBFT协议部分指定。 回想一下，BFT的环境需要为BFT实现一个签名oracle。当作为一个子协议在DailyBFT内部运行时，签名oracle是通过DailyBFT协议实现的。根据诚实的DailyBFT协议的定义，诚实的节点永远不会公开他们的签名密钥。对于这样的（BFT）环境，如果4.2节中指定的安全属性可以被p.p.t.对手A破坏。我们可以构造一个减少签名安全性的Re。

上述基本上允许我们证明，当BFT在DailyBFT内部作为子协议实例运行时，BFT的环境很好，因此BFT的所有声明安全属性将保持不变，除非忽略概率。此证明的其余部分此后依赖于BFT的这些属性来作出论证。

## 8 详细的证明
下面是我们对Nakamoto的混合共识的证明，以及混合共识的证明除了改变的参数外，Fruit链是一样的。

### 8.1术语和简单事实
**子协议的环境。** 在执行与A，Z的混合共识协议时,让（A，Z）[subprot[sid]]成为子协议实例subprot [sid]接口的对手/环境对。（A，Z）[subprot[sid]]由（A，Z）定义，并且混合共识的一部分外部到subprot[si]。 我们还使用符号Z[subprot[sid]]来表示子协议实例subprot[sid]与之对接的环境。 回想一下第5.3节中的图2说明了我们的混合共识协议的模块组成。

下面的事实表明，如果DailyBFT的环境输入一些start（comm），其中comm包含节点i输出的pk，在时间t≥T<sub>start</sub>时是诚实的，那么节点i必须在T<sub>start</sub>之前输出pk。换句话说，DailyBFT的环境无法预测诚实节点输出的未来pk对。这个简单的事实在整个过程中都很方便，因为每当我们说一些pk∈comm由一个诚实的节点i输出时，这个诚实的节点隐含地是一个委员会成员。 回想一下，根据定义，对于节点i被认为是委员会成员，它必须在T<sub>start</sub>之前输出一些pk∈comm。

**事实1**（公钥的不可预测性）。假设签名方案是安全的，它必须对任何p.p.t（A，Z）和任何λ∈N都有效。以下性质适用于exec[DailyBFT]（A，Z，λ），其中概率是1 - negl（λ）：

如果Z输入到任何诚实的节点start（comm），并且让i在t≥T<sub>start</sub>时刻是诚实的节点，并且输出pk∈comm，么它认为节点i是诚实的委员会成员w.r.t. DailyBFT在时间t，即，pk∈comm必须在T<sub>start</sub>之前由i输出。

证明。很简单，一个安全的签名方案必须具有高熵的公共钥匙。

**事实2.**
对于一个安全的签名方案，多项式中许多诚实生成的公钥不会与1-negl（λ）概率相冲突。

因此，今后我们简单地假设诚实节点生成的签名公钥不会相互冲突。

### 8.2 混合共识证明
**值得注意的事件。**
给定引理2，我们知道对于每个多项式有界的R∈N，（A，Z）[DailyBFT[R]]尊重委员会的一致性。因此，对于协议实例DailyBFT [R]，诚实的委员会成员的概念是明确的。为了方便起见，我们明确定义重要事件的以下时间。

- T<sub>start</sub>（R）：诚实的委员会成员开始进入其DailyBFT[R]实例的最早时间;
- T<sub>stop</sub>（R）：一个诚实的委员会成员输入停止到其DailyBFT[R]的最早时间。
- T<sub>stamp</sub>（R）：=T<sub>start</sub>（R）+λ/G+T<sub>bft</sub>+δ+T<sub>snail</sub>。

**引理2**
（DailyBFT的环境满足委员会协议，关闭开始和停止，以及临时静态腐败）。令（A，Z）为（n，α，δ，τ）-有效的w.r.t. 混合一致性,对于任何n∈N，α> 0，δ> 0和τ>3λ/G+T<sub>bft</sub>+δ+T<sub>snail</sub>的，使得snail链满足一致性，Q链质量和（G，G'）链增长w.r.t. （A，Z[snailchain]）对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）具有1 - negl（λ）概率.

对于任何R=poly（λ）∈N，（A，Z）[DailyBFT [R]]关闭启动和停止以及临时静态腐败满足委员会协议。

证明。 委员会协议直接从混合共识的定义和snail链的一致性属性中得出。

从混合共识的定义和从snail链一致的长度属性（这是链式增长的一部分）开始直接停止。

从T<sub>stamp</sub>（R）和基础τ-agile腐败模型的定义中可以看出，暂时的静态腐败是一种直接的方式。

**事实3 **
（有限的一天的长度）。令（A，Z）为（n，α，δ，τ）-有效的w.r.t.任何n∈N，α> 0，δ>0和τ≥0的混合共识使得snail链满足一致性，Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]。那么，对于任何λ∈N，以下为具有1-negl（λ）概率的exec[HybridConsensus]（A，Z，λ）：

2λ=G' ≤ T<sub>start</sub>(1) ≤2λ/G,
∀R = poly(λ)∈N:Ts<sub>start</sub>R) + λ/G' ≤ T<sub>stop</sub>(R)=T<sub>start</sub>(R+1)≤T<sub>start</sub>(R) + λ/G

证明。 对于满足上述要求的（A，Z）对，对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）的下列表达式具有1-negl（λ）概率。

事实上，T<sub>stop</sub>（R）=T<sub>start</sub>（R+1）从简单的方式跟随诚实的混合共识协议的定义。此外，通过对诚实混合共识协议的定义，诚实节点在其本地链长度达到csizeR+λ时向DailyBFT [R-1]发送停止。通过（G，G'）链增长，得出T<sub>start</sub>（R）+λ/ G'≤T<sub>stop</sub>（R）=T<sub>start</sub>（R+1）≤T<sub>start</sub>（R）+ csize/G=T<sub>start</sub>（R）+λ/ G。类似地，通过（G，G'）链增长，认为2λ/G'≤T<sub>start</sub>（1）≤2λ/ G。

此后，我们将假设exec[HybridConsensus]（A，Z，λ）将断言在事实1，引理2和事实3中声明的不良事件。如果发生这样的不良事件，则执行中止。由于所有这些不良事件都是以negl（λ）概率出现的，所以断言不良事件的新执行在计算上难以区别于满足事实1，引理2和事实3中指定条件的（A，Z）对。

特别是，由于我们假设委员会的意见一致，今后我们将使用符号commR来表示在任何具体观点中支持exec[HybridConsensus]（A，Z，λ）的第R天全球议定的委员会。

**引理3**
（足够多的commR成员保持诚实，直到Tstamp（R））。令Q，G，G'是λ，n，α，δ中的多项式有界函数。 对于任何Tbft> 0和任何常数η>0，设T<sub>snail</sub>：=（1 +η）λ=G，令（A，Z）为（n，α，δ，τ） -有效的w.r.t.对于任何n∈N，α> 0，δ> 0和τ>3λ/ G+T<sub>bft</sub> +δ+ T<sub>snail</sub>的混合一致性，使得snail链满足一致性，Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]。 那么，对于任何λ∈N，具有1-negl（λ）概率的exec[HybridConsensus]（A，Z，λ）:

对于任何R=poly（λ）∈N，至少Q分数是由保持诚实的节点输出的.

T<sub>stamp</sub>(R):=T<sub>start</sub>(R) + λ=G + T<sub>bft</sub> + δ + T<sub>snail</sub>,

证明。 对于满足上述要求的（A，Z）对，对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）的下列表达式具有1-negl（λ）概率。

让链随时成为一个诚实的节点的本地链z在任何时候都是|chain|≥upper（R）。通过Q链质量，并且由于csize=λ，chain[lower(R),upper(R)]，w.r.t.chain[：lower（R）-1]至少有Q部分是完整的块。这意味着对于至少Q个指数i∈[lower(R),upper(R)]的部分，存在一个节点j，它在某个较早的时间t完好无损，从而输出到Z [snailchain]链在时间t-1包含前缀链[：lower（R）-1]，并且Z[snailchain]在时间t向节点j提供输入链[i]：=（recs，pk）。根据混合共识协议的定义，pk∈commR和pk必须是时间t处的某个DailyBFT [R]节点j的实例的输出。现在由于（G，G'）链增长，在t和T<sub>start</sub>（R）之间经过的最多（csize +λ）/ G =2λ/G时间。最后，由于τ>（3λ/ G + T<sub>bft</sub>+δ+T<sub>snail</sub>）的敏捷性，我们有节点j保持诚实直到T<sub>stamp</sub>（R）。因此，通过T<sub>stamp</sub>（R）之前保持诚实的节点输出至少Q部分的commR。

接下来，我们证明T<sub>stamp</sub>（R）被选择得足够远以便为所有commR成员的DailyBFT实例提供足够的时间来输出彼此一致的最终每日日志（可能为空）。

**事实4**（DailyBFT的环境是有效的。）。 令Q，G，G'是λ，n，α，δ中的多项式有界函数。对于任何T<sub>bft</sub>>0和任何常数η>0，假设T<sub>snail</sub>：=（1+η）λ=G，令（A，Z）为（n，α，δ，τ）-有效的w.r.t.对于任何n∈N，α> 0，δ> 0和τ>3λ/ G+T<sub>bft</sub> +δ+T<sub>snail</sub>的混合共识，使得Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]满足snail链一致性。

然而，（A，Z，λ）：（A，Z）[DailyBFT [R]]为（n，Q，δ，τ，T<sub>stamp</sub>（R），Tbft）-有效的w.r.t.DailyBFT。

证明。简单地将引理2、3和事实3结合起来。

**引理4**
（及时加戳）。设G，G'，Q为λ，n，α，δ中的多项式有界函数，假设DailyBFT对于具有活性参数T<sub>bft</sub> 的（1-Q）腐败是安全的。对于任何常数η> 0，令T<sub>snail</sub> ：=（1 +η）λ= G。令（A，Z）为（n，α，δ，τ） - 有效的w.r.t. 对于某些n∈N，α> 0，δ> 0和τ>3λ/G+T<sub>bft</sub>+δ+T<sub>snail</sub>的混合共识，使得Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]满足snail链一致性。那么，对于任何λ∈N，具有1-negl（λ）概率，对于exec[HybridConsensus]（A，Z，λ）以及任何R=poly（λ）∈N，以下属性成立。

假设任何诚实的节点在时间t≥T<sub>stamp</sub>（R）时输出一个链。对于任何在T<sub>stamp</sub>（R）处诚实的节点i输出的任意pk∈commR，令h：=hash（log<sub>R</sub>）其中，log<sub>R</sub>表示由节点i的DailyBFT[R]实例输出的最终日志，则有效记录形式{R，h}<sub>pk-1</sub>（其中有效性由签名验证定义）包含在chain[：-λ]中，并且对于不同的h'≠h它不会以任何其他形式为{R，h'}<sub>pk-1</sub>的有效记录 。

证明。 对于满足上述要求的（A，Z）对，对于任意λ∈N，exec[HybridConsensus]（A，Z，λ）的下列表达式具有1-negl（λ）概率。

由于事实4，（A，Z）[DailyBFT[R]]是（n，α，δ，τ，Q;T<sub>stamp</sub>（R），T<sub>bft</sub>）-有效的w.r.t. DailyBFT。通过事实1，对于节点i输出的这种pk∈commR，在时间T<sub>stamp</sub>R）处诚实，节点i是诚实的委员会成员w.r.t.DailyBFT[R]。因此，通过及时终止DailyBFT，节点i的DailyBFT[R]实例将通过时间T<sub>stop</sub>（R）+ T<sub>bft</sub>输出完成一些元组（日志，recs）。根据诚实的混合共识算法的定义，节点i将调用snailpool：由T<sub>stop</sub>（R）+T<sub>bft</sub>提出（recs）;根据mempool协议的定义，每个诚实节点的snailpool：TXs将包含T<sub>stop</sub>（R）+T<sub>bft</sub> +δ的recs。因此，从时间T<sub>stop</sub>（R）+T<sub>bft</sub>+δ开始，在每个时间步中，Z[snailchain]将其输入中的recs包含在snail链中，用于每个本地链[：-λ]尚未包含rec的诚实节点。通过snail链的活性特性，在T<sub>stop</sub>（R）+ T<sub>bft</sub>+δ+ T<sub>snail</sub>之后的任何时刻，recs将出现在每个诚实节点的本地链[：-λ]中。根据DailyBFT协议的完备性质，{R，h}<sub>pk-1</sub>∈recs，其中h：= hash（log）。最后，由于事实3，T<sub>stop</sub>（R）-T<sub>start</sub>（R）<λ= G。因此它认为，每个诚实节点的本地链[：-λ]将包含{R，hash（log）}<sub>pk-1</sub>，在时间T<sub>stamp</sub>（R）=T<sub>start</sub>（R）+λ= G +T<sub>bft</sub>+δ+Tsnail时，其中log是节点i的DailyBFT[R]实例的最终每日日志输出。

我们现在证明这样一个元组rec={R，h}<sub>pk-1</sub>是第一个出现在chain [：-λ]中的类型，也就是说，没有其他形式的有效记录rec'：={R，h'}<sub>pk-1</sub>，其中h'≠h在链中rec之前。我们通过矛盾来证明。假设在链[：-λ]之前有一个这样的元组rec。由于rec在t<sub>stamp</sub>时刻必定出现在chain [：-λ]中，由于snail链的一致性属性，所以必须rec'。然而，通过对诚实的DailyBFT算法的定义，一个诚实的节点不应该输出具有不同最终日志的两个不同的完成（ - ，-）消息。因此，如果rec'通过时间T<sub>stamp</sub>出现在一个诚实的节点链中[：-λ]，这显然违反了DailyBFT的不可伪造性属性。

事实5（没有晚产生的DailyBFT）。设G，G'，Q为λ，n，α，δ中的多项式有界函数，假设DailyBFT对于具有活性参数Tbft的（1-Q）腐败是安全的。对于任何常数η> 0，令T<sub>snail</sub>：=（1 +η）λ/ G。令（A，Z）为（n，α，δ，τ）-有效的w.r.t. 对于某些n∈N，α> 0，δ> 0和τ>3λ/G+T<sub>bft</sub>+δ+T<sub>snail</sub>的混合共识，使得Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]满足snail链一致性。那么，对于任何λ∈N，具有1-negl（λ）概率，以下属性适用于exec[HybridConsensus]（A，Z，λ）和适用任何R=poly（λ）∈N。

如果按时间T<sub>stamp</sub>（R）产生，一个诚实的节点只会分派一个DailyBFT[R]实例。

证明。根据混合共识算法和引理4的定义。

**引理5**（追溯一致性）。设Q>2/3，令G，G'为λ，n，α，δ中的多项式有界函数。 假设DailyBFT对于具有活性参数T<sub>bft</sub>的（1-Q）腐败是安全的。 对于任何常数η>0，设T<sub>snail</sub>：=（1+η）λ=G，令（A，Z）为（n，α，δ，τ）-有效的w.r.t.对于某些n∈N，α> 0，δ> 0和τ>3λ/ G +Tbft +δ+ T<sub>snail</sub>的混合共识，使得Q链质量和（G，G'）链增长w.r.t. （A，Z）[snailchain]满足snail链一致性，那么对于任意λ∈N，exec[HybridConsensus]（A，Z，λ）以及任何R = poly（λ）∈N具有1-negl（λ）概率。

让链在任何时候表示一个诚实节点的输出。 假设（R，h）是链上有效元组w.r.t.它认为节点i输出的pk∈commR输出在Tstamp（R）处诚实，并且h=hash（log<sub>R</sub>），其中log<sub>R</sub>是节点i的DailyBFT[R]输出的（唯一的）最终每日日志实例。

证明。 对于满足上述要求的（A，Z）对，对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）具有1-negl（λ）概率。

对于（R，h）是一个有效的链元组w.r.t. 链，对于至少[csize/3]pk∈commR：1）正确签名的元组{R，h}<sub>pk-1</sub>必须出现在链[：-λ]中;2）这个元组是链上第一个出现{R，h}<sub>pk-1</sub>形式的有效元组。

通过事实4，得到在时间T<sub>stamp</sub>（R）处诚实的节点输出至少Q部分的commR。假设Q>2/3，并且由于鸽舍原理，对于至少一个由某个公钥pk签署的这种签名，它必须保证它由节点i（在T<sub>start</sub>（R）之前）输出，对T<sub>stamp</sub>（R）保持诚实。根据引理4，这个签名必须证明（R,hash（log）），其中log表示节点i输出的（唯一的）最终日志。

**定理10**
（混合共识的一致性）。假设哈希：H：{0,1}*→{0,1}<sup>λ</sup>是独立的随机过程，并且签名方案Σ是安全的。 设Q>2/3，令G，G'为λ，n，α，δ中的多项式有界函数。假设DailyBFT对于（1-Q）是安全的-具有活跃性参数T<sub>bft</sub>的腐败。对于任何常数η>0，令T<sub>snail</sub>：=（1+η）/λ=G。令（A，Z）为（n，α，δ，τ）-有效的w.r.t. 对于某些n∈N，α>0，δ>0和τ>3λ/ G + T<sub>bft</sub>+δ+T<sub>snail</sub>的混合共识，使得Q链质量和（G，G'）链增长w.r.t.（A，Z）[snailchain]满足snail链一致性。然后，对于任何λ∈N，具有1-negl（λ）概率，exec[HybridConsensus]（A，Z，λ）满足3.2节定义的一致性。

证明。 对于“混合共识”的定义，自我一致性是微不足道的。下面我们重点说明证明通用前缀。对于满足上述要求的（A，Z）对，对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）具有1-negl（λ）概率。

根据诚实的混合共识算法的定义，我们可以解析一个诚实节点的LOG为下面的式子，其中R∈N：

LOG := log1||log2||...||logR−1||log<sub>R</sub>

对于r∈[R]的每个记录器，可以是下列情况之一：

1.每日offchain共识的最终日志。logr是DailyBFT[r]实例输出的最终日志。 通过事实5，它认为这个节点在T<sub>stamp</sub>（r）之前产生。

2.每日offchain共识的非最终日志。logr包含在DailyBFT[r]实例的输出中，其输出形式为notdone（log<sub>r</sub>）——在这种情况下，通过定义诚实的混合共识算法，它必须是log<sub>r</sub>中包含的最近每日日志。此外，事实5，它认为这个节点在T<sub>stamp</sub>（r）之前产生。

3.匹配链上有效元组。有一个链上有效元组（r，h）w.r.t.诚实节点的本地链[：-λ]使得hash（logr）= h。

首先，请注意，如果一个诚实节点i的DailyBFT [r]实例输出logr归因于1，并且诚实节点j的DailyBFT[r]实例（相同或不同）输出log'<sub>r</sub>归因于1，它必须保持log<sub>r</sub>=log'<sub>r</sub>。DailyBFT的一致性属性很简单。

其次，如果一个诚实节点i的DailyBFT [r]实例输出logr归因于1，而一个诚实节点j的DailyBFT[r]实例（相同或不同），则输出log'<sub>r</sub>归因于2，那么它必须保存该log'<sub>r</sub>≺logr<sub>r</sub>。这紧接着来自DailyBFT的一致性属性。

接下来，如果一个诚实的节点j（相同或不同）输出log'<sub>r</sub>归因于3，那么必须存在一个诚实节点i，输出log<sub>r</sub>归因于1，使得log<sub>r</sub>=log'<sub>r</sub>。这直接来自引理5，以及哈希oracle具有可忽略的碰撞概率的事实。

其余的证明以一种直接的方式进行，通过观察，由于事实3，日长在λ中多项式有界，并且对于所有r=poly（λ）∈N，至少有一个pk∈commr在Ts<sub>stamp</sub>r）处是诚实的，并且将在时间T<sub>stamp</sub>（r）上完成输出（ - ;-)。

**定理11**
（混合共识的活跃度）。 假设哈希：H：{0,1}*→{0,1}λ是独立的随机过程，且签名方案Σ是安全的。设Q> 2/3，令G是λ，n，α，δ中的函数。假设DailyBFT对于具有活性参数T<sub>bft</sub>的（1-Q）腐败是安全的。对于任何常数η>0，令T<sub>snail</sub>：=（1 +η）λ=G。假设（A，Z）为（n，α，δ，τ） - 对于某些n∈N，α> 0，δ> 0和τ>3λ/ G + T<sub>bft</sub> +δ+ T<sub>snail</sub>有效的w.r.t.混合共识，使得Q链质量和（G，G'）链增长 （A，Z）[snailchain],G'<λ/T<sub>bft</sub>+δ满足snail链一致性。然后，对于任何具有1-negl（λ）概率的λ∈N，exec [HybridConsensus]（A，Z，λ）满足3.2节中定义的活性，参数T<sub>warmup</sub>：=2λ/G，T<sub>confirm</sub>：= 2T<sub>bft</sub> +2δ。

证明。 对于满足上述要求的（A，Z）对，对于任何λ∈N，exec[HybridConsensus]（A，Z，λ）具有1-negl（λ）概率。

假设Z在时间t≥T<sub>warmup</sub>=2λ/G时将TXs输入到某个诚实节点。根据txpool协议的定义，在t+δ时刻，所有诚实的节点都有TXs⊆Txpool：TXs。假设一个诚实的节点i在t'≥t+T<sub>confirm</sub>= t+2T<sub>bft</sub>+2δ时是诚实的，并且我们表明在时间t'节点i的输出LOG必须包含所有的TXs。

通过事实3以及G'>λ/T<sub>bft</sub>+δ，T<sub>start</sub>（1）≤2λ/ G = T<sub>warmup</sub>的事实。此外，对于任何R∈N，T<sub>start</sub>（R）<Ts<sub>stop</sub>（R）-T<sub>bft</sub>-δ<T<sub>start</sub>（R+1）。设R是使得t≤Ts<sub>stop</sub>（R）-T<sub>bft</sub>-δ的最小整数。现在，以下两种情况之一必须是真实的：

- 案例1：t≥T<sub>start</sub>（R）= T<sub>stop</sub>（R - 1）。

在这种情况下，根据混合共识和事实4的定义，存在一个诚实的commR成员,它的Z [DailyBFT[R]]将包括TXs\LOG到其输入到DailyBFT[R]t+δ<T<sub>stop</sub>（R） -T<sub>bft</sub>。

- 情况2：T<sub>stop</sub>（R-1）-T<sub>bft</sub>-δ<t<T<sub>stop</sub>（R-1）=T<sub>start</sub>（R）<T<sub>stop</sub>（R）-T<sub>bft</sub>

在这种情况下，根据混合共识和事实4的定义，存在一个诚实的commR成员，其Z [DailyBFT[R]]将包括TXs\LOG到其由T<sub>start</sub>（R）<t+T<sub>bft</sub>输入到DailyBFT [R] +δ。

因此，在任何一种情况下，存在一个诚实的commR成员，其在时间t'<t+T<sub>bft</sub>+δ时其Z[DailyBFT[R]]将包括TXs\LOG到其到DailyBFT[R]的输入中，使得T<sub>start</sub>（R）≤t'<T<sub>stop</sub>（R）-T<sub>bft</sub>。此后让LOG*表示该时间t'时该委员会成员的输出LOG。

- 我们首先证明，如果节点i曾经分叉过一个DailyBFT实例，并且在时间t'≥t+ 2T<sub>bft</sub>+2δ时是诚实的，那么节点i在时间t'的输出LOG将包括所有的TXs。

通过事实5，如果节点i分叉了一个DailyBFT [R]实例，则它的t<sub>spawn</sub>≤T<sub>stamp</sub>（R）。通过DailyBFT协议的活性属性和事实4，如果节点i在时间t'≥t+ 2T<sub>bft</sub> +2δ时是诚实的，那么通过节点i的DailyBFT [R]实例必须具有输出done（logR， - ）以致TXs\LOG*⊆log<sub>R</sub>。 现在，对于任何1≤r≤R-1，根据诚实的混合共识协议的定义，任何一个节点我都没有分叉DailyBFT[r]实例，而logr是在预处理期间计算的（见图4）。 或节点i做了一个DailyBFT[r]实例。在后一种情况下，由于事实5，我们知道节点i由T<sub>stamp</sub>（r）分支。通过事实4和DailyBFT协议的及时终止属性，如果节点i在时间t'≥t+2T<sub>bft</sub>+2δ时是诚实的，节点i的DailyBFT [r]实例将在时间t'完成输出。

通过对诚实的混合共识协议的定义，如果节点i在时间t'≥t+2T<sub>bft</sub> +2δ时是诚实的，则其输出LOG将在时间t'包含所有TXs\LOG *。

- 在考虑节点时i没有分叉DailyBFT [R]实例的情况。在这种情况下，节点i必须通过匹配链上有效元组来计算logR，并且在时间t<sub>spawn</sub>中输出log<sub>R</sub>。由于事实4，在时间T<sub>stamp</sub>（R）处必须存在至少一个由某个节点v输出的至少一个pk∈commR，并且通过DailyBFT的及时终止属性，节点v的DailyBFT[R]实例将在诚实的时候输出log<sub>R</sub>。通过DailyBFT的活性属性，由节点ν输出的最终日志logR必须包含所有TX \ LOG *。

由于定理10，节点i的log<sub>R</sub>输出必须与节点ν的DailyBFT[R]实例的输出相同，因此它必须包含所有的TXs \ LOG*。

最后，由于混合共识的一致性，对于在时间t'≥t+2T<sub>bft</sub>+2δ>t''时诚实的任何节点，让LOG在时间t''输出它，那么它认为LOG'≺LOG或 LOG≺LOG '。 但是，由于TXs\LOG'⊆LOG，它必定是LOG'≺LOG的情况。因此我们得出结论TXs⊆LOG。

### 8.3 每日Offchain共识证明
在一些观点中，假设（A，Z）是协议DailyBFT的对手/环境对，我们使用符号（A，Z）[BFT]来表示与BFT子协议实例接口的对手/环境对。（A，Z）[BFT]由（A，Z）以及诚实的DailyBFT协议共同定义。 请注意，在节点i损坏后，Z[BFT]向A [BFT]显示运行在节点i上的所有BFT实例的所有公共/秘密密钥。

**引理6**
（在DailyBFT环境中的BFT安全性）.如果BFT对于（1-Q）腐败以及活性参数T<sub>bft</sub>由定义5具有很强的安全性，并且进一步BFT用安全签名方案Σ实例化，则对于任何n，δ，T<sub>stamp</sub>> 0，τ≥0,P.P.T.（A，Z）即（n，Q，δ，τ，T<sub>stamp</sub>，T<sub>bft</sub>）-有效的w.r.t.DailyBFT，存在可忽略的函数negl，使得对于任何λ∈N，

Pr [view←exec[DailyBFT](A,Z,λ):secure<sup>T<sub>bft</sub></sup>(view) = 1] ≥ 1−negl(λ)

其中secure<sup>T<sub>bft</sub></sup>（view）如4.2节所述定义但用“诚实的BFT虚拟节点”取代任何“诚实的节点”。

证明。我们在下面构造一个p.p.t.还原Re。

- 还原Re与签名挑战者Σ*相互作用，并获得表示为pk *前向的签名公钥。 今后我们将pk *作为挑战公钥。
- 还原Re将模拟所有运行DailyBFT的诚实节点。 当某个诚实节点的BFT虚拟节点要求keygen时，Re翻转一个随机硬币，并以概率1 / n返回挑战公钥pk *; 否则，减少Re使用诚实算法生成签名密钥对。 因此，减少Re知道除嵌入质询公钥pk *的坐标之外的所有秘密签名密钥。 只要一个诚实的节点的BFT虚拟节点发出询问公钥pk *的签名查询，Re就简单地将查询转发给签名挑战者。
- 还原Re与环境Z相互作用。只要Z向真实节点输入任何东西，Re就会简单地将消息转发到其头部模拟的相应诚实节点。 每当一个模拟的诚实节点需要输出任何东西给Z时，还原Re只是转发消息。 同样，还原Re也转发Z和A之间的任何消息。

现在，如果一个诚实的节点在某一点变得腐败，Re需要将节点的私有状态返回给Z.只要腐败节点不是嵌入了pk*的节点，还原Re就可以成功模拟。如果腐败节点恰好是pk
*嵌入的地方，那么还原就会中止。很明显，还原不中止的可能性是不可忽略的。

很明显，在还原Re不中止的事件的条件下，还原与（A，Z）的接口被相同地分配为DailyBFT协议的实际执行。

不难看出（A、Z）是（n、Q、T<sub>stamp</sub>、T<sub>bft</sub>）-有效的w.r.t.DailyBFT，然而在1 −negl(λ)
概率下（A，Z）[BFT]是（n，Q，δ，τ，T<sub>stamp</sub>）-有效的w.r.t.BFT。特别是，使用Σ：Gen（1<sup>λ</sup>λ）算法诚实生成的公钥具有negl（λ）碰撞概率，否则签名方案很容易被破坏。

假设引理不是真的，即存在一些多项式g和p.p.t.（A，Z）即（n，Q，δ，τ，T<sub>stamp</sub>，T<sub>bft</sub>） - 有效的w.r.t. DailyBFT以致

Pr [view←exec[DailyBFT](A,Z,λ):secure<sup>T<sub>bft</sub></sup>(view)≠1] ≥g'(λ)

其中secure<sup>T<sub>bft</sub></sup>（view）的定义与4.2节相似，但是与DailyBFT中的虚拟BFT节点有关。 根据强安全性的定义（见定义5），我们知道存在一个p.p.t.对手B和多项式g'以致

Pr [view←exec[DailyBFT](A,Z,λ):secure<sup>T<sub>bft</sub></sup>(view)=1] ≥g'(λ)

现在，考虑还原Re与（B，Z）交互的执行。 如前所述，只要执行不中止，从（B，Z）的角度来看，执行就是一个真正的执行。因此，用不可忽略的概率，B将输出给Re一些伪造品，并且如果伪造品恰好是以非可忽略概率发生的pk*，则还原Re将发现对签名方案是伪造的。

**定理12**
（来自BFT的DailyBFT，定理7的重述）。假设DailyBFT所使用的签名方案是安全的，而哈希是一个随机的oracle。假设BFT对于Q>2/3的活性参数T<sub>bft</sub>'可以抵御（1-Q）腐败。然后，DailyBFT对于（1-Q）-活性参数T<sub>bft</sub>：=T<sub>bft</sub>'+δ的腐败是安全的。

证明。 对于任何（n，Q，δ，τ，T<sub>stamp</sub>，Tb<sub>bft</sub>）-有效的任何（A，Z），任何n，δ，T<sub>stamp</sub>>0，任何τ≥0。DailyBFT，exec [DailyBFT]（A，Z，λ）具有以下属性，但可忽略的概率除外：

- 及时终止。由于BFT的环境遵守紧急停止，所有BFT虚拟节点都通过T<sub>stop</sub>+δ接收停止。通过BFT的活性属性和DailyBFT的定义，所有诚实的委员会成员保持诚实，直到T<sub>stop</sub> + T<sub>bft</sub>'+δ=T<sub>stop</sub> +T<sub>bft</sub>将在时间T<sub>stop</sub>+T<sub>bft</sub>的日志中，停止通过[|comm|/3]通信中的不同公钥。当发生这种情况时，根据DailyBFT诚实委员会成员的定义，对其每日日志的签名散列进行传播，并输出完成（ - ，-）。由于至少Q>2/3的comm部分由委员会成员输出，直到T<sub>stamp</sub>>T<sub>stop</sub>+T<sub>bft</sub>保持诚实，所以不难看出，如果委员会非成员在时间T<sub>stop</sub> + T<sub>bft</sub>+δ时是诚实的， 将收集足够的签名并将完成输出（-，-)。
- 一致性。

-自洽性。根据每日的定义，自恰性是显而易见的

终止协议。根据定义，一个诚实的委员会成员只会输出与最终日志输出相同的最终日志，这是内部BFT<sub>0</sub>虚拟节点（停止事务删除）。根据底层BFT的一致性属性，如果一个诚实的委员会成员，i的BFT在某个时刻输出日志，并且一个诚实的委员会成员j的BFT在某个时刻输出log'，它必须保持log ≺ log'或者log ≺ log'。

如果节点i和j在Tstamp之前产生并且输出完成（ -，-），但它们仍然是诚实的，那么完成（-，-）必须不晚于T<sub>stamp</sub>输出。通过对诚实的DailyBFT算法的定义，一定是他们在终止时输出相同的每日日志。我们现在将终止协议证明延伸至在T<sub>stamp</sub>之前产生的委员会非成员。这将取决于签名方案的安全性。假设一些委员会非会员k在T<sub>stamp</sub>之前产生，并且在某些时候输出完成（log *， - ），这是诚实的。它一定是这种情况

1.由于及时的终止属性，完成（log*， - ）由时间T<sub>stamp</sub>输出;

2.log*可以被解析为

log∗ = tx∗<sub>1</sub>||tx∗<sub>2</sub>||...tx∗<sub>l*</sub>

3.对于其中i∈[l*]的每个（R，i，tx<sub>i</sub>），并且对于其中R是会话标识符的元组（R，l），节点k已经接收到至少[1/3|comm|]的不同公钥的数量。

由于至少Q部分comm是由Tstamp诚实的委员会成员输出的，并且由鸽巢原理决定，每个元组（R，i，txi）或元组（R，i）至少有一个有效签名，l*）是由一个节点v输出的pk∈comm输出，直到Ts<sub>stamp</sub>保持诚实。如前所述，诚实的委员会成员输出相同的最终每日日志，以后称为日志。 解析log：= tx<sub>1</sub>||...||tx<sub>l</sub>。

假设对于log*≠log的矛盾。那么必须存在一个元组（R，i，tx *<sub>i</sub>）或（R，l *），使得tx *<sub>i</sub>≠tx<sub>i</sub>或l *≠1。不失一般性，假设tx * <sub>i</sub>≠tx<sub>i</sub>（另一种情况相似）。然后，节点k将在节点v输出的pk∈comm签名的（R，i，tx * <sub>i</sub>）上接收至少一个有效签名，该节点保持诚实直到Tstamp。如果存在p.p.t. （A，Z）使得log *≠log具有不可忽略的概率，那么我们可以建立一个打破签名方案的还原。基本上这种减少模拟所有诚实用户并与（A，Z）对交互。只要Z输入keygen，它就可以从签名的挑战者中选择嵌入一个pk。要做到这一点，每次keygen被查询时，减少都会进行随机猜测并决定是否嵌入签名挑战者的pk。这种猜测对于1 / poly（λ）概率是正确的——并且如果猜测后来证明是错误的，那么简化会简单地中止。每当嵌入式PK需要签名时，缩减就会查询签名挑战者。对于所有其他密钥对，缩减知道相应的秘密密钥，并且当节点变得腐败时可以将其公开给（A，Z）。最后，当（A，Z）在这样一个元组{R，i，tx *<sub>i</sub>}<sub>pk-1</sub>上输出一个有效签名时，缩减输出这个伪造。请注意，因为tx
*<sub>i</sub>≠tx<sub>i</sub>，所以减少不应该对签名挑战者进行这样的查询。

-通用前缀。假设委员会成员i和j在时间t和t'分别是诚实的，并且我在时间t输出日志，并且j在时间t'输出日志。 由于及时的终止属性，必须是t <T<sub>stamp</sub>和t'<T<sub>stamp</sub>的情况。现在，由于底层BFT和DailyBFT定义的一致性属性，不难看出log ≺ log'或log'≺ log。

我们现在将这个论点扩展到在T<sub>stamp</sub>之前产生的委员会非成员。 这里我们依靠签名方案的安全性。让k是在T<sub>stamp</sub>之前产生的任何非委员会成员。我们认为，如果节点k的输出完成（log'，-），那么log'必须与诚实的委员会成员的最终日志记录为日志——正如我们前面所述，所有诚实的委员会成员必须输出相同的最终日志; 根据定义，至少有一名委员会成员在T<sub>stamp</sub>之前保持诚实。

如果节点k在诚实时输出notdone（log *
），那么由于及时终止属性和诚实节点在输出done（-，-）后从不再输出这一事实，它必须保证notdone（log*
）在T<sub>stamp</sub>之前输出。 现在解析log*：= log
*<sub>1</sub>|| ... || log *<sub>m</sub>，并解析log：= log<sub>1</sub> || ... || log<sub>l</sub>。 那么它必须保证l≥m且log *<sub>i</sub>  = log<sub>i</sub>——后者可以使用与终止协议完全相同的参数类型来显示。

活跃度。 根据DailyBFT协议的定义，任何在t时刻向诚实委员会成员输入的TXs都会在相同的时间步t输入到内部BFT虚拟节点。此外，内部的BFT虚拟节点与外部的DailyBFT具有相同的T<sub>start</sub>和T<sub>stop</sub>，因为诚实的委员会成员只是将启动和停止命令传递给内部的BFT虚拟节点。

根据BFT协议的活泼性，如果T<sub>start</sub>≤t<T<sub>stop</sub>-T<sub>bft</sub>，对于在时间t+T<sub>bft</sub>诚实的任何委员会成员，其内部BFT虚拟节点将在时间t+T<sub>bft</sub>输出包括所有TX的日志。由于t<T<sub>stop</sub>-T<sub>bft</sub>，完整的（log）必须返回false，否则我们可以轻松构造一个破坏签名安全性的对手。

现在考虑一下所有委员会成员在t + T<sub>bft</sub>时刻诚实，对于每个委员会成员，考虑它在时间t+T<sub>bft</sub>输出的最长日志。现在取所有这些日志的交集并将其表示为日志。我们认为TXs⊆log'，并且显然完成（log'）= false。现在，根据DailyBFT协议的定义，对于每个i∈[|og'|]，对于由T<sub>stamp</sub>诚实的某个节点输出的每个pk∈comm，它必须保证每个节点在t + T<sub>bft</sub> +δ时刻诚实 已经收到有效签名的元组{R，i，log'[i]}<sub>pk-1</sub>，其中R是DailyBFT的会话标识符。在T<sub>stamp</sub>> t + T<sub>bft</sub>+δ之前，节点保持诚实的节点必须至少有[Q | comm |]个pks。由于Q>2/3，任何在t+T<sub>bft</sub>+δ时刻诚实的节点都会输出一个log *
s.t.|log*
|≥时间t + T<sub>bft</sub> +δ。 通过DailyBFT的一致性，log * 
[i] = log'[i]，因此tx∈log*。

- 完整性。DailyBFT的定义和签名方案的正确性显而易见。
- 不可伪造性。如果存在p.p.t.（A，Z），使得不可伪造性可以以不可忽视的概率被破坏，那么我们可以建立一个减少破坏签名方案。基本上这种减少模拟所有诚实用户并与（A，Z）对交互。只要Z输入keygen，它就可以从签名的挑战者中选择嵌入一个pk。要做到这一点，每次keygen被查询时，减少都会进行随机猜测并决定是否嵌入签名挑战者的pk。这种猜测对于1/poly（λ）概率是正确的 - 如果猜测后来证明是错误的，那么简化会简单地中止。每当嵌入式PK需要签名时，缩减就会查询签名挑战者。对于所有其他密钥对，缩减知道相应的秘密密钥，并且当节点变得腐败时可以将其公开给（A，Z）。此后我们假设嵌入的pk属于节点i。最后，当（A，Z）在这样一个元组{R，h}<sub>pk-1</sub>上输出一个有效签名时，这个缩减输出这个伪造。注意，减少不应该对签名挑战者进行这样的查询（R，h），因为根据定义，（A，Z）对破坏不可伪造性，它一定是这样的情况，即节点i没有输出done（log，-）伪造品，使得h = hash（log）。

### 8.4 将混合共识的证明扩展到Fruit链上
到目前为止，我们已经完成了对Nakamoto的混合共识的证明。当我们使用Fruit链作为潜在的snail链时，证明几乎是一样的，除了参数必须重新调整。

考虑混合共识<sub>λ,η</sub>用η参数化。 换句话说，委员会规模csize被选为csize：=λ/η。在证明中，我们可以插入以下修改后的参数：

- T<sub>snail</sub>:=(2λ+λ/η)/G;
-  T<sub>stamp</sub>(R):=T<sub>start</sub>(R) +λ/ηG+ T<sub>bft</sub> + δ + T<sub>snail</sub>;
- τ > (2λ/η+λ)=G + T<sub>bft</sub> + δ + T<sub>snail</sub>=3λ(1+1/η)/G + T<sub>bft</sub> + δ;
- T<sub>warmup</sub>:=λ(1+1/η)/G;
- G'> λ/η(T<sub>bft</sub>+δ);
- G = (1 − 5η)(1 − α)nρ, and G'= (1 + 5η)nρ.

有了这些新的参数，其余的证明就如同Nakamoto的混合共识一样。

##  下界
### 9.1 工作量证明不能停止
我们现在证明了一个下界，暗示任何安全的无许可的共识协议都必须无限次地调用工作证明，假设没有额外的信任假设。我们强调，这个下界并不排除依赖额外信任假设的方法，如<font color=#FF0000>[11,38,49,50]</font>。

**定理13**
（任何安全的无许可共识协议都必须无限地调用工作证明）令Γ表示n，α，δ，τ中的任意二元函数，使得对于作为正多项式（在λ中），非负多项式τ和α的一些n，δ的Γ（n，α，δ，τ）=1而且对于某些正多项式poly，α >1 / poly。 Π是一个协议，任何p.p.t.（A，Z）是Γ可容许的，存在一个多项式函数poly，使得对于每个λ∈N，exec[Π（A，Z，λ）满足1 / poly（λ）概率的下列性质：

- 有界的工作证明。诚实的节点在一段时间后停止查询H：对于某些多项式poly<sub>0</sub>，Tpow：=poly<sub>0</sub>（n，α，δ，λ）;
- 活跃度。在3.2中定义的活跃度对于一些非负多项式poly<sub>1</sub>，poly<sub>2</sub>和poly<sub>3</sub>满足参数T<sub>confirm</sub>=poly<sub>1</sub>（n，α，δ，λ），T<sub>warmup</sub>=poly<sub>2</sub>（n，α，δ，λ）和T<sub>bootstrap</sub>=poly3<sub>3</sub>（n，α，δ，λ）。

然后，存在p.p.t.（A,Z）是Γ-可容许的，这样对于任何λ∈N，exec[Π]（A，Z，λ）对于某些多项式poly不满足概率1 / poly（λ）。

直觉上，这个定理表明任何无许可的共识协议都可以抵御1/poly（λ）的腐败部分，即使在同步网络模型中也必须无限制地调用工作证明，并且要抵抗静态腐败。

证明。 Π是任何协议，以便任何p.p.t. （A'，Z'）是Γ-可容许的，则存在多项式函数poly，使得对于具有1/poly（λ）概率的每个λ∈N，exec[Π]（A'，Z'，λ）满足有限的上述定义的工作量证明和活跃度。我们现在展示如何构建p.p.t.（A，Z）是Γ-可允许的，使得exec[Π]（A，Z，λ）对于某些多项式多项式以1/poly（λ）概率打破公共前缀性质。

我们考虑一个Γ可容许的w.r.t.Π对（A，Z），并表现如下。

**交易输入。**
在时间T<sub>warmup</sub>，Z采样tx←{0,1}<sup>λ</sup>，并且输入TXs：= {tx}到一个诚实的节点。除此之外，Z不输入任何其他交易。

**真正的执行。**指示所有的腐败节点在实际执行中表现得诚实。

**模拟执行。** 从时间T<sub>pow</sub>开始，A也模拟头脑中的假想执行。为此，A模拟所有诚实节点和环境Z的执行。假设在该模拟执行中，模拟环境Z在模拟时间T<sub>warmup</sub>输入TXs = {tx*}其中tx *←{0,1}<sup>λ</sup>。

**网络和腐败。**
在真实的和模拟的执行中，对手A会立即传递消息，也就是。在接下来的时间里。环境静态地破坏节点的部分。

**晚产生的节点。** 假设一个新的节点i在时间t<sub>spawn</sub>处产生t<sub>spawn</sub>：= max（T<sub>pow</sub>+T<sub>pow</sub> =α; <sub>warmup</sub>+T<sub>confirm</sub>）+1。此时，攻击者A将具有所有模拟诚实节点与节点i交互，其中所有模拟诚实节点遵循诚实的协议。 每当节点i闲聊一条消息时，消息就会在δ= 1时间内传递给真实节点中的真实节点，并且传递给模拟执行中的诚实节点。

**没有一致性。**现在，具有1/poly（λ）概率，对于真实和模拟执行，有界证明和活性都满足。条件是这些属性满足真实和模拟执行，我们认为一致性不能满足至少1/2的概率。

假设节点的α分数是腐败的，不难看出在任何时候t≥t<sub>spawn</sub>-1，攻击者A能够输出与真实执行相同分布的模拟执行，因为攻击者A会有足够的时间来完成所有必要的H查询。

现在，由于活跃度，真正执行的诚实节点必须通过t<sub>spawn</sub>-1输出一个LOG，其中tx∈LOG和tx*∉LOG-除了具有negl（λ）概率，因为真正的执行无法知道tx
*之前的t产生。类似地，除了negl（λ）概率外，模拟执行中的诚实节点必须通过t<sub>spawn</sub>-1输出一个LOG，并且其中tx *∈LOG和tx∉LOG。

由于活跃度，新产生的节点i必须通过时间max（t<sub>spawn</sub>+T<sub>bootstrap</sub>，T<sub>warmup</sub> + T<sub>confirm</sub>）输出非空LOG，使得tx∈LOG。而且由于真实和模拟的执行是相同的分布，tx*∈LOG也是如此。 由于真实和模拟执行的分布是相同的，因此tx *在LOG之前的概率至少为1 / 2——在这种情况下，一致性（对于实际执行）不能得到满足。

### 9.2 1/3腐败对于响应性协议很要紧
我们现在表明，在无共识模型中，即使协议知道网络延迟的先验上限Δ，也不存在响应协议，该协议在哈希功率方面可以容忍1/3或更多的损坏。由于我们的混合共识协议容忍1/3-ε腐败，它是（几乎）紧张，因为没有响应协议可以容忍超过1/3腐败。

我们的下界是对Sompolinsky<font color=#FF0000>[2]</font>证明的相关下界的直接修改，他证明了在部分同步的情况下，如果网络的延迟上限对于协议是未知的，那么没有安全的无许可的共识协议可以容忍多于1/3的腐败。我们的下界证明（也是Sompolinsky's）也同样贴近Dwork，Lynch和Stockmeyer <font color=#FF0000>[25]</font>所示的部分同步下界。然而，他们的约束需要适应无许可的环境和工作证明。特别是，Dwork等人的下界构造了一个3个节点的显式攻击，其中一个节点由对手控制，作为具有不同输入的两个单独节点，并与两个诚实节点交互以拆分它们的视图。在工作证明设置中，难点在于对手不能同时模拟两个节点，因为这样做必须解决两次工作证明。然而，我们使用类似于Sompolinsky的技巧<font color=#FF0000>[2]</font>，即对手仍然扮演两名参与者的角色，但是随着时间的推移将工作证明分开——而受害者诚实的节点无法区分对手是否迟到开始解决难题，或者仅仅是网络延迟很大。

**定理14**
（响应协议不能容忍1/3损坏）。没有安全的无许可的协商一致也可以容忍1/3或更多的腐败。

证明。 假设存在协议Π，该协议Π抵御1/3的讹误并且是响应的，即其活性参数T<sub>confirm</sub>=T<sub>confirm</sub>（λ，n，α，δ）是网络实际延迟δ的函数，但不是已知上限延迟Δ。这意味着，在一些T<sub>warmup</sub>=poly（λ，n，α，δ，Δ）时间之后，即使在1/3节点崩溃的情况下，输入到诚实节点的事务将包含在T<sub>confirm</sub>时间内的任何诚实节点的输出LOG中。

我们现在描述一个明确的攻击，当α=1/3时可以打破一致性。假设有3个节点A，P<sub>0</sub>和P<sub>1</sub>，其中A由对手A控制，并且P<sub>0</sub>和P<sub>1</sub>是诚实的。令Δ：= 2T<sub>confirm</sub>（λ，n，α，T<sub>confirm</sub>（λ，n，α，1）），它是以λ表示的多项式。攻击者A首先表现诚实，并在T<sub>warmup</sub>（λ，n，α，1，Δ）时间过去之前立即传递所有消息。

此时，攻击者A开始将P<sub>0</sub>和P<sub>1</sub>之间的消息延迟最大量Δ，但在P<sub>0</sub>和A之间立即传送消息。此时，环境Z将事务tx←{0,1}λ输入到P<sub>0</sub>和一个不同的事务tx'←{0,1}λ到P<sub>1</sub>。此外，受损节点A停止向P<sub>1</sub>发送消息; 但是，它会记住并存储从P1接收到的每条消息。与P<sub>0</sub>交互时，受损节点遵循诚实协议。由于即使1/3节点发生崩溃，协议也是响应的，除了可忽略的概率外，P<sub>0</sub>的输出LOG将在某个固定多项式时间T<sub>confirm</sub>（λ，n，α，1）<Δ中包含tx。

令t *
= T<sub>warmup</sub>（λ，n，α，1，Δ）+ T确认（λ，n，α，1）表示当tx包含在P<sub>0</sub>的输出LOG中时的上限。在时间t*
，受损节点A停止向P<sub>0</sub>发送消息，但开始与P<sub>1</sub>进行交互，如下所示。首先，A将其内部状态重置为Tsub>warmup</sub>时的状态。回想一下，A将收到的所有消息P<sub>1</sub>排队在缓冲区中。它现在假装任何实时t≥t*是假的时间t-T<sub>confirm</sub>（λ，n，α，1），并且它在实时步骤t-T<sub>confirm</sub>期间从（从缓冲器）重放从P<sub>1</sub>接收的所有消息（λ，N，α，1）。现在A遵循诚实的协议，并且针对每个发往P1的消息，敌手立即传递消息。请注意，P<sub>1</sub>无法区分A是否开始求解工时证明T<sub>confirm</sub>（λ，n，α，1）时间晚，或者从A到P1的网络链接是否具有T<sub>confirm</sub>（λ，n，α，1）实际延迟，但P1到A链接立即传递消息。由于协议即使在1/3节点崩溃时也是响应，所以P1将在T<sub>confirm</sub>（λ，n，α，T<sub>confirm</sub>（λ，n，α，1））<Δ时间的输出LOG中包括tx'≠tx。请注意，由于Δ很大，P1还没有听到来自P0的事务tx。因此，在时间T<sub>confirm</sub>（λ，n，α，T<sub>confirm</sub>（λ，n，α，1））中，tx在P<sub>1</sub>的输出记录中的概率在λ中可以忽略不计。显然，这打破了一致性。

**备注。**
我们注意到，对于经典的许可设置，要显示一个类似的下界并不难。具体地说，在经典的许可设置中，即使在假定PKI的情况下，任何响应性的、安全的共识协议都不能容忍1/3的腐败或更多。这样一个较低的界限将是对Dwork等人的下界证明的简单概括，即与未知（在许可的环境中）的部分同步。

## 感谢
我们感谢Kyle Croman，Ittay Eyal，Ari Juels，Antonio Marcedone，Andrew Miller，Emin Gun Sirer，Yonatan Sompolinsky，Dawn Song和Fan Zhang作了有益的讨论，尤其是Dominic Williams多次出色的讨论激励我们解决了这个问题。

这项工作部分支持NSF拨款CNS 1217821，CNS-1314857，CNS-1514261，CNS-1544613，CNS-1561209，CNS-1601879，CNS-1617676，AFOSR奖FA9550-15-1-0262，海军办公室 研究青年研究者计划奖，微软教师奖学金，帕卡德奖学金，斯隆奖学金，谷歌教师研究奖和VMWare研究奖。这项工作部分完成，部分作者访问西蒙斯理论研究所 由Simons基金会和DIMACS/Simons通过NSF授权CNS-1523467进行密码学协作提供支持。

## 参考文献
[1] Personal communication with Kartik Nayak and Ling Ren.

[2] Personal communication with Yonatan Sompolinsky.

[3] Byzcoin: Securely scaling blockchains.http://hackingdistributed.com/2016/08/04/byzcoin/.

[4] Untangling mining incentives in bitcoin and byzcoin.http://bford.github.io/2016/10/25/mining/.

[5] Martın Abadi and Jan Jurjens. Formal eavesdropping and its computational interpretation.
In Theoretical Aspects of Computer Software, 4th International Symposium (TACS), pages
82-94, 2001.

[6] Martın Abadi and Phillip Rogaway. Reconciling two views of cryptography (the computational
soundness of formal encryption). J. Cryptology, 20(3):395, 2007.

[7] Pedro Ad~ao, Gergei Bana, Jonathan Herzog, and Andre Scedrov. Soundness of formal en-cryption in the presence of key-cycles. In Computer Security - ESORICS 2005, 10th European
Symposium on Research in Computer Security, Milan, Italy, September 12-14, 2005, Proceed-ings, pages 374-396, 2005.

[8] Gavin Andresen. Increase maximum block size (bip 101). https://github.com/bitcoin/
bips/blob/master/bip-0101.mediawiki, retrieved October 2015.

[9] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller,
Andrew Poelstra, Jorge Timon, and Pieter Wuille. Enabling blockchain innovations with
pegged sidechains.https://blockstream.com/sidechains.pdf.

[10] Michael Backes, Birgit Pfitzmann, and Michael Waidner. A universally composable crypto-graphic library. IACR Cryptology ePrint Archive,2003:15, 2003.

[11] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. CoRR,
abs/1406.5694, 2014.

[12] Alysson Neves Bessani, Jo~ao Sousa, and Eduardo Ad´ılio Pelinson Alchieri. State machine
replication for the masses with BFT-SMART. In 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2014, Atlanta, GA, USA, June 23-26,2014, pages 355-362, 2014.

[13] Florian Bohl and Dominique Unruh. Symbolic universal composability. In Proceedings of the 2013 IEEE 26th Computer Security Foundations Symposium, CSF ’13, pages 257-271, 2013.

[14] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. J. ACM,
32(4):824{840, October 1985.

[15] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and efficient
asynchronous broadcast protocols. In Advances in Cryptology - CRYPTO 2001, 21st Annual
International Cryptology Conference, Santa Barbara,California, USA, August 19-23,2001,Proceedings, pages 524-541, 2001.

[16] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.

[17] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61-85. Springer, 2007.

[18] Ran Canetti and Jonathan Herzog. Universally composable symbolic security analysis. J.
Cryptology, 24(1):83-147, 2011.

[19] Ran Canetti and Tal Rabin. Fast asynchronous byzantine agreement with optimal resilience.
In Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing, STOC’93, pages 42-51, 1993.

[20] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.

[21] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.

[22] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gun Sirer, Dawn Song, and Roger Wattenhofer.
On scaling decentralized blockchains (a position paper). In Bitcoin Workshop, 2016.

[23] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In Proceedings of the 17th International Conference on Distributed Computing and Networking,ICDCN ’16, 2016.

[24] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement.
Siam Journal on Computing-SIAMCOMP, 12(4):656-666, 1983.

[25] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.

[26] Pieter Wuille Eric Lombrozo, Johnson Lau. Segregated witness (consensus layer).https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki.

[27] Ittay Eyal, Adem Efe Gencer, Emin Gun Sirer, and Robbert van Renesse. Bitcoin-NG: A
scalable blockchain protocol. In NSDI, 2016.

[28] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC,2014.

[29] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed
consensus with one faulty process. J. ACM, 32(2):374-382, April 1985.

[30] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol: Analysis
and Applications. Cryptology ePrint Archive, Report 2014/765, 2014.

[31] Jeff Garzik. Block size increase to 2mb (bip 102). https://github.com/bitcoin/bips/blob/master/bip-0102.mediawiki,retrieved October 2015.

[32] Jeff Garzik. Making decentralized economic policy. http://gtf.org/garzik/bitcoin/
BIP100-blocksizechangeproposal.pdf.

[33] Omer Horvitz and Virgil D. Gligor. Weak key authenticity and the computational completeness
of formal encryption. In CRYPTO, pages 530{547, 2003.

[34] Romain Janvier, Yassine Lakhnech, and Laurent Mazar´e. Completing the picture: Soundness
of formal encryption in the presence of active adversaries. In Programming Languages and
Systems, 14th European Symposium on Programming,ESOP 2005, Held as Part of the Joint European Conferences on Theory and Practice of Software (ETAPS), pages 172-185, 2005.

[35] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst.Sci.,75(2):91-112, February 2009.

[36] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols.
Cryptology ePrint Archive, Report 2015/1019, 2015.

[37] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and
Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective
signing. CoRR, abs/1602.06997, 2016.

[38] Jae Kwon. TenderMint: Consensus without Mining, August 2014.

[39] Leslie Lamport. Fast paxos. Distributed Computing,19(2):79{103, 2006.

[40] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In Proceedings of the 28th ACM Symposium on Principles of Distributed Computing,PODC ’09, pages 312-313, 2009.

[41] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM
Trans. Program.Lang.Syst.,4(3):382-401, July 1982.

[42] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. IEEE Trans. Dependable
Secur. Comput., 3(3), 2006.

[43] Daniele Micciancio and Bogdan Warinschi. Completeness theorems for the Abadi-Rogaway
language of encrypted expressions. J. Comput. Secur., 12(1):99-129, January 2004.

[44] Daniele Micciancio and Bogdan Warinschi. Soundness of formal encryption in the presence of
active adversaries. In Theory of Cryptography Conference (TCC), 2004.

[45] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of BFT
protocols. Cryptology ePrint Archive, Report 2016/199, 2016. http://eprint.iacr.org/.

[46] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.

[47] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.

[48] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. Manuscript, 2016.

[49] Ryan Pfeiffer. The decrits consensus algorithm: Decentralized agreement without proof of work. CoRR, abs/1411.1101, 2014.

[50] QuantumMechanic. Proof of stake instead of proof of work. bitcointalk.org, July 2011.

[51] David Schwartz, Noah Youngs, and Arthur Britto. The Ripple Protocol Consensus Algorithm,
September 2014.

[52] Isaac C. Sheff, Robbert van Renesse, and Andrew C. Myers. Distributed protocols and heterogeneous trust: Technical report. CoRR, abs/1412.3136, 2014.

[53] Marko Vukolic. The quest for scalable blockchain fabric: Proof-of-work vs. BFT replication. In Open Problems in Network Security - IFIP WG 11.4 International Workshop, iNetSec 2015, Zurich, Switzerland, October 29, 2015, Revised Selected Papers, pages 112-125, 2015.

[54] Pieter Wuille. Block size following technological growth (bip 103). https://github.com/
bitcoin/bips/blob/master/bip-0103.mediawiki.

## 附录
### 关于许可BFT的背景
我们使用PBFT<font color=#FF0000>[21]</font>作为例子简要描述一个可能的许可BFT协议实例。粗略地说，PBFT<font color=#FF0000>[21]</font>是拜占庭式状态机复制的部分同步协议。

下面我们非正式地描述当n=3f+1时的情况。 为更一般的情况n>3f+1修改协议并不难。在我们的描述中，我们假设交易是以称为批次的单位提出的。

**正常情况下的操作。** 我们首先描述PBFT协议的正常情况下的操作，其中所有消息都由发送者签名。

1.当前视图的领导者向所有节点提出一个元组("propose",v, l,batch) ，其中v表示视图编号，l表示序列号。

2.当一个诚实的节点听到("propose",v, l,batch)时，如果它没有为（v，l）发送一个准备消息，它则多广播("propose",v, l,batch) 。

3.当一个诚实的节点从同一（v, l,batch)元组的2f+1个不同节点收集,v, l,batch)时，它多播（“commit”，v，l，batch）。此外，诚实的节点现在考虑准备（v，l，batch）：= 1。

4.当一个诚实节点首先从同一个（v，l，batch）元组的2f+1个不同节点收集（“commit”，v，l，batch）或者当它首先从同一个（v，l，batch）元组的f + 1个不同节点收集（“commit”，v，l，batch）时：节点认为lcommitted（v，l，batch）：=1，并且multicasts（“commited”，v，L，batch）。这里commited的是“本地提交”的简称。

正常情况下的协议满足以下重要属性：

- 协议。 如果两个诚实的节点都相信已准备（v，l，batch）：=1并准备好（v，l，batch'）：= 1，则batch = batch'。
- 在一个诚实的领导下活跃。如果领导者是诚实的，并且没有诚实的节点从最近的观点开始就已经超时，那么由真正的节点提交的任何批次将由O（1）原子时间步骤由所有诚实节点在本地提交。
- 充分的准备证明。 如果至少有一个诚实节点认为lcommitted（v，l，batch）：= 1，那么至少f + 1诚实节点认为准备好了（v，l，batch）：= 1。

如果一个诚实的节点相信准备好的（v，l，batch）：=1，那么它就可以产生2f+1的签名准备消息，从而导致了这个信赖。我们指的是这些2f+1的收集信息的准备工作。

请注意，协议属性的直接影响是，如果两个诚实的节点都认为lcommitted（v，l，batch）：=1且lcommitted（v，l，batch'）：=1，那么batch=batch'。 然而，正常情况下的操作并不能保证在潜在的腐败领导下，如果一个诚实的节点认为lcommitted（v，l，batch）：= 1，其他诚实的节点必然会认为lcommitted（v，l，batch）这因此激发了视图更改协议。

**视图更改。** 只有正常情况下的协议并不能保证领导者腐败时的保证活跃度，即使领导者已经损坏，超时时也会调用视图更改协议。 为了获得O（nδ）最坏情况下的响应时间，我们可以对PBFT的原始指数退避策略进行一个小的修改：相反，超时可以使n个视图变化加倍。在部分同步模型中，当超时退回到Θ（δ）并且领导者诚实时，随之而来的是活力。

粗略地说，如果一个诚实的节点听到f + 1对新视图v'的有效视图改变请求，它将通过为视图v'多播一个视图改变消息本身来回应视图改变请求。

当新视图的领导者收集2f+1个有效视图更改请求时，2f+1个有效视图更改请求集合将形成一个新视图消息。 领导人
然后向所有节点建议新视图消息。 当一个诚实的节点接收到新视图消息时，对于新视图消息中包含的每个（v，l，batch）准备好的准备证明，节点就好像它刚收到一个（“propose”，v，l，batch）消息，因此为该元组多播了一个准备消息，并且继续在正常情况下操作。

由于正常情况操作的“准备充分”，属性如下：如果一个诚实的节点认为lcommitted（v，l，batch）=1，那么至少有一个有效的准备证明将会包含在任何有效的新视图消息中。这确保了如果至少一个诚实的节点认为lcommitted（v，l，batch）=1，则元组（v，l，batch）保证继续到新视图，并且因此如果其他诚实节点本地提交(v，l，batch'），它认为batch = batch'。

最后，只要新领导人是诚实的，并且新观点中没有诚实的节点已经超时，那么新观点随之而来的就是活跃度。

我们将读者引用到PBFT文件<font color=#FF0000>[21]</font>中，详细描述视图更改协议以及检查点优化。 在PBFT论文<font color=#FF0000>[21]</font>中形式化证明并不困难，并将它们扩展到一个密码良好的框架。此外，要证明PBFT协议实现了我们4.2节定义的强大安全概念并不难。
