# 水果链：一条公平的区块链

Nakamoto著名的区块链协议可以在所谓的无许可设置中达成共识-任何人都可以加入（或离开）协议执行，协议指令不依赖于玩家的身份。他的巧妙协议依靠Dwork和Naor（Crypto'92）引入的计算难题（a.k.a.“适度硬函数”）来防止“sybil攻击”（对手产生任意数量的新玩家）。Garay等人（EuroCrypt'15）和Pass等人（手稿，2016）最近的工作表明，该协议可以证明a）诚实的玩家控制网络中的大部分计算能力，b）难题——根据最大网络延迟和网络的总计算能力适当地设置硬度，以及c）将计算难题建模为随机预言。然而，假设诚实参与是一个强有力的假设，特别是在诚实玩家需要执行大量工作（解决计算难题）的环境中。在Nakamoto的区块链协议的比特币应用中，玩家可以通过接收他们为区块链贡献的每个“区块”（交易）奖励来激励解决这些难题。Eyal和Sirer（FinancialCrypt'14）的工作加强并正式化比特币论坛上讨论的早期攻击，表明一个联盟甚至控制网络中少数部分计算能力通过偏离协议指令就可以获得（接近）2倍“公平分享”奖励（和交易费用）。相反，在一个公平协议中，可以预期控制计算资源的φ分数的玩家获得奖励的φ分数。

在这篇文章中，我们提出了一种新的区块链协议——FruitChain协议——它满足与Nakamoto协议相同的一致性和活性属性（假设计算能力的大部分是诚实的），并且另外是δ-近似公平：以极大的概率，控制计算能力的φ分数的任何诚实的一组参与者保证在链的任何Ω（κ/δ）长度段中获得至少一部分（1-δ）φ的块（并因此奖励）（其中κ是安全参数）。因此，如果将此区块链协议用作加密货币系统下的分类账，其中奖励和交易费用均匀分布在链条长度κ段的区块矿工中，通过偏离协议，没有控制小于大部分计算能力的联盟可以获得超过因子（1 +3δ）（即，诚实参与是n / 2-联盟-安全的3δ-Nash均衡）。最后，FruitChain协议可以减少采矿奖励的差异，从而显着减少（甚至消除）采矿池的需求。

## 1 介绍

分布式系统在封闭环境中进行了历史分析——a.k.a.允许的设置——系统中参与者的数量以及他们的身份是常识。在2008年，Nakamoto<font color="#006600">[Nak08]</font>提出了他著名的“区块链协议”，试图在无许可的环境中达成共识：任何人都可以加入（或离开）协议执行（未获得集中或分布式权限的许可），以及协议指令不依赖于玩家的身份。粗略地说，核心区块链协议（又名“Nakamoto共识”，或“Bare-bones区块链协议”）是一种维护公共，不可变和有序记录分类帐的方法（例如，在比特币应用程序中，这些记录只是交易）;也就是说，记录可以随时添加到分类帐的末尾（但仅限于结尾）; 此外，我们保证以前添加的记录无法删除或重新排序，并且所有诚实用户都具有统一的分类帐视图——我们将此称为一致性。此外，该协议应该满足活跃属性：诚实用户提交的交易足够快地合并到分类帐中。

无许可设置的关键挑战是攻击者可以轻易地进行所谓的“sybil攻击”——它只会产生许多玩家（它控制着），因此可以轻松确保它控制所有玩家的大多数。实际上，Barak等<font color="#006600">[BCL+05]</font>证明了这是无许可模型的基本问题。 Nakamoto区块链协议依靠“计算难题”_a.k.a.克服了这个问题。Dwork和Naor<font color="#006600">[DN92]</font>提出了适度硬函数或工作证明：粗略地说，参与者需要解决一些定义明确的难度的计算难题，以便确认交易——这被称为挖掘。接下来，Nakamoto的目标是在假设大部分计算能力得以保留的情况下提供协议的稳健性，而不是试图在大多数参与者诚实时提供稳健性（因为参与者可以在无许可环境中轻松生成）。 诚实的参与者。的确，Garay等人<font color="#006600">[GKL15]</font>和Pass等人<font color="#006600">[PSS17]</font>最近的工作正式证明，Nakamoto的区块链协议满足上述不同网络假设下的一致性和活跃度，只要拼图难度（称为挖掘硬度）被适当地设置为网络中最大延迟的函数。

Nakamoto的区块链代表了一个令人兴奋的突破：它证明了在互联网规模上可以实现分布式共识。然而，上述分析假设大部分计算能力由诚实的玩家控制，并且诚实玩家正确执行协议。假设这种诚实参与是一个强有力的假设，特别是在诚实玩家需要执行大量工作（解决计算难题的环境中）——为什么我们期望玩家想要参与，如果它是昂贵的！（这可以在Halpern和Pass<font color="#006600">[HP15]</font>的Costly计算框架的Game-Theory中形式化)。在Nakamoto巧妙的比特币区块链协议应用中，玩家可以通过接收所谓的块区奖励来激励他们解决这些难题，这些区块奖励是他们为区块链做出贡献的每一块“交易”。此外，矿工还会收到块区确认的所有交易的交易费用。希望这些奖励机制（区块奖励和交易费用）能够恰当地激励诚实参与。不幸的是，正如最近几项工作所示，事实并非如此：

- 自私的采矿破坏了激励相容性。Nakamoto的区块链遭受所谓的自私采矿攻击，即使是控制网络交付的少数联盟也可以获得近两倍的公平份额的奖励<font color="#006600">[mtg10，ES14，SSZ16，CKWN16，NKMS16]</font>——特别是 如果对手拥有接近一半的计算能力，它几乎可以获得所有的奖励，从而否定了（几乎）任何奖励的诚实玩家！（更具体地说，每当对手开采一个新区块时，它只是扣留它（不与诚实玩家共享），只有当一些诚实玩家开采新区块时才释放它——如果对手控制网络，它可以确保 所有诚实的玩家在由诚实玩家挖掘的区块之前都会收到对抗区块，因此，它会有效地“擦除”诚实玩家的区块，用自己的区块替换它。）这种自私的挖掘攻击最初是在比特币论坛<font color="#006600">[mtg10]</font>的讨论中观察到的; Eyal和Sirer<font color="#006600">[ES14]</font> 提供的第一项分析研究，随后由Sapirshtein等人<font color="#006600">[SSZ16]</font>和Nayak等人<font color="#006600">[NKMS16]</font>进行了改进。
- 交易费用加剧了不稳定性。由于比特币特定的铸币计划，块奖励计划随着时间的推移而减少，预计矿工将从交易费中获得越来越多的奖励。Carlsten等人 <font color="#006600">[CKWN16]</font>最近的一项工作（与我们同时发生）表明，一旦我们考虑到交易费用，情况会变得更糟：作为一个最简单的例子，如果一个区块包含大额费用的交易，矿工将被激励创建“分叉”并尝试自己确认交易。
- 采矿池损害了权力下放。最后，为了保持区块链的一致性，难题是（并且通过<font color="#006600">[PSS17]</font>的分析需要设置）以便整个世界大约每10分钟组合一个区块（即，解决计算难题）。因此，拥有最先进设备的个体“独立采矿者”需要平均等待，在获得任何奖励之前2年<font color="#006600">[sol]</font>。这导致了“采矿池”的形成，矿工由池操作员协调，并分享奖励以减少其收益的变化。 实质上，区块链的分散性质已经丧失。

### 1.1 我们的结果
在这项工作中，我们引入了区块链协议的公平性概念：粗略地说，我们说区块链协议是公平的，如果诚实的玩家发挥部分的计算资源将在任何足够长的时间内获得至少φ分数的区块链的窗口。这种公平的概念可以被视为“理想链质量”概念的强化形式“在<font color="#006600">[GKL15，PSS17]</font>中考虑但未实现）更准确地说，我们说区块链协议是δ-近似公平的w.r.t。ρ 攻击者如果以极大的概率，保证诚实用户的任何φ分数联盟在链的每个足够长的窗口中至少获得块的（1-δ）φ分数，即使存在对手控制到ρ分数的计算能力。我们的主要定理展示了如何实现一个区块链，它满足与Nakamoto相同的一致性和活性属性，以及公平性：

**定理1.1**（非正式声明）。设ρ<1/2为常数。 然后，对于每个常数δ>0，存在满足一致性，活性和δ近似公平性的区块链协议。

请注意，近似公平性直接意味着攻击者不能获得比块奖励的公平份额“更多”（因此它不利于自私采矿）。但交易费用的不稳定性问题仍然存在，矿业池问题也是如此。我们最终证明我们的协议也为这两个问题提供了解决方案：

- 关于交易费用：我们建议采用一种方法，将一块区块的交易费用分摊到其前面的一系列区块。正如我们所示，任何公平的区块链协议都可用于在即使在新的奖励规则下存在交易费的情况下也能够抑制偏差。更确切地说，我们表明，控制不到大多数计算能力的联盟可以通过偏离协议获得超过因子（1+3δ）的块奖励和交易费用的，也就是说，诚实参与是n/2-联盟-安全的3δ-Nash均衡。
- 关于采矿池，我们证明我们的方案中的块（即水果）采矿难度几乎可以任意小，因此，矿工可以更频繁地获得报酬。 实际上，实施我们的新区块链<font color="#006600">[BHP+]</font>的实验结果显示，当比特币当前块大小为1MB时，通过牺牲8％到10％的块到新的元数据，我们可以确保矿工获得1000倍的报酬（因此平均下来，大致是每天两次）。因此，不再需要汇集采矿。

### 1.2 协议概述
为了解释我们的协议，让我们首先回顾Nakamoto的区块链协议，因为我们将使用它。

**简单的说Nakamoto协议。** 粗略地说，玩家通过解决一些计算难题来“挖掘交易块”来“确认”记录/交易，这些计算难题是到目前为止交易和历史的函数。更准确地说，每个参与者都保持其自己的“链”的“块”的记录——称为区块链。每个块由一个三元组（h<sub>-1</sub>，η，m）组成，其中h<sub>-1</sub>是链中前一个块的指针，m是块的记录组件，η是“工作证明”——从（h<sub>-1</sub>，m）导出计算难题的解决方案。到目前为止，工作证明可以被认为是整个区块链中的“无键数字签名”。

具体地说，Nakamoto的协议通过参数p进行参数化——我们将其称为挖掘硬度参数，并且如果η是一个字符串使得H（h<sub>-1</sub>，η，m）<D<sub>p</sub>，则认为工作证明是有效的。其中H是散列函数（被建模为随机预言）并且D<sub>p</sub>被设置为使得满足该关系的输入的概率小于p。在协议执行的任何时刻，每个参与者都试图通过“挖掘”新块来增加其自己链的长度：在接收到一些记录m时，它选择随机η并检查η是否是有效的工作证明w.r.t.m和h<sub>-1</sub>，其中h<sub>-1</sub>是指向其当前链的最后一个块的指针;如果是这样，它扩展是自己的本地链并将其广播给所有其他参与者。每当参与者收到比其本地链更长的链时，它就会用更长的链替换自己的链。

**FruitChain协议。** 粗略地说，我们的协议，我们称之为FruitChain协议，将运行Nakamoto区块链协议的实例，但不是直接将记录存储在区块链内，而是将记录放在表示为f的“水果”中。 这些水果本身需要解决一些工作证明，具有不同的硬度参数p<sub>f</sub>;另外，我们要求水果从链中的一个块中“悬挂”，该块与记录水果的块不太“远”，更具体地说，水果需要“指向”链中较早的块且离包含它的区块不太远。（因此，水果不可能在很久以前开采过）——我们将这种水果称为最近的水果。在这个新的协议中，水果起着“块”的作用——“橘子是新的块”<sup>1</sup>——因此链的质量根据水果来定义。

在每一轮中，诚实的玩家通过调用哈希函数同时挖掘水果和块（对于Nakamoto区块链）——这遵循<font color="#006600">[GKL15]</font>的2对1技巧，例如，输出的前缀H确定水果采矿是否成功，后缀用于确定区块采矿是否成功。每当玩家成功挖掘水果时，它会将其广播给所有其他玩家;尚未记录在区块链中（并且仍然是最近的）的水果存储在缓冲区中，所有诚实的玩家接下来都会尝试将它们添加到区块链中。

直觉上，“自私采矿”失败的原因在于，即使对手试图通过底层区块链的链增长和链质量属性“擦除”由诚实玩家（其中包含一些诚实的果实）开采的某些区块，最终 一个诚实的玩家将挖掘一个稳定的新区块，这个诚实的玩家将包括其中的水果——事实上，在这样一个“诚实的块”到来之前的时间足够短，以至于在诚实块抵达时水果仍然是“最近的”。

直觉上，我们之所以要求水果最近是为了防止不同类型的攻击：没有它，攻击者可以扣留水果，并突然同时释放大量水果，从而在（水果）链的某些部分产生很大一部分对抗性水果。通过要求水果是最近的，我们防止对手躲避（太多）其果实：由于底层区块链具有保证的活力，我们可以上限攻击者可以扣留水果的额外时间，从而使数字上限，它可以在任何窗口释放多余的水果。

### 1.3 相关工作
**与GHOST，包容性区块链和<font color="#006600">[GKL15]</font>的比较** 尽管我们从GHOST<font color="#006600">[SZ15]</font>和包容性区块链<font color="#006600">[LSZ15]</font>的早期工作中获得灵感：在主要区块链中包含水果的方法，但我们强调这些早期工作并未实现我们提供可证明安全，公平的区块链的目标。GHOST<font color="#006600">[SZ15]</font>是一种机制，使得不在主链上的分叉块将影响链选择规则——然而，正如Kiayias和Panagiotakos <font color="#006600">[KP16]</font>的后续工作所示，GHOST实际上恶化了“链质量”（即，链中的诚实块的一部分）而我们的目标是提高链条质量和公平性。包容性区块链工作建议保持直接的非循环图而不是链，这样分支的子树可以包含在线性化的交易中——尽管表面上看似相似，但包容性区块链所采用的机制实际上与我们如何在主要区块链中包含水果有所不同。

如上所述，我们的协议从Garay等<font color="#006600">[GKL15]</font>的工作中借用了2对1技巧，该工作也依赖于单独的“挖掘过程”来实现不同的目标（即，从区块链实现广播信道）。

**后续的工作。** 在Nakamoto的区块链协议和我们的区块链协议中，确认交易所需的时间随着网络延迟<font color="#006600">[PS16，PSS17]</font>的最坏情况上限而增长。相反，在响应协议中，我们要求确认时间仅是实际网络延迟的函数，实际网络延迟可能比最坏情况下的延迟小很多。在一篇名为混合共识<font color="#006600">[PS16]</font>的配套论文中，我们展示了如何将任何区块链协议与经典的异步共识相结合，以改善区块链协议的延迟并实现响应协议。粗略地说，混合共识利用区块链来选举一个委员会——更具体地说，在链条的足够长的部分中的区块的矿工被选为委员会——然后该委员会执行经典的共识协议。区块链的链条质量决定了委员会中诚实参与者的比例：如果我们使用Nakamoto的区块链，我们需要要求3/4的计算能力由诚实的玩家控制，以确保链条质量为2/3因此，成为2/3诚实委员会成员（这是共识协议所要求的）。相比之下，依靠我们新的FruitChain协议，可以假设2/3的计算能力是由诚实的玩家控制的。我们强调，如<font color="#006600">[PS16]</font>所示，实现响应协议还需要假设2/3的计算由诚实的各方持有，因此依赖我们的FruitChain协议可以实现低延迟区块链的最佳弹性。

除了混合共识之外，其他后续工作也采用了FruitChain的想法来实现区块链式协议中的激励兼容性。值得注意的是，最近可证明安全的股权证明协议，包括Snow White<font color="#006600">[BPS16]</font>和Ouroboros<font color="#006600">[KRDO16]</font>，认为FruitChain的想法也适用于非工作证明区块链。

**其他相关工作**  Kiayias等人<font color="#006600">[KKKT16]</font>将比特币挖掘作为一种游戏模型，其中节点决定扩展哪些块以及是否释放挖掘块。他们表明，对于控制不到1/3资源的小型玩家，遵循比特币的协议规范是一种Nash均衡。然而，他们的结果仅适用于一个相当有限的理想主义模型，其中所有诚实的矿工都可以通过0延迟进行通信，并且攻击者无法执行任何网络级攻击（例如冲动）。正如我们在引言中提到的那样，在我们的模型中，攻击者可以控制消息的传递，即使对于控制不到1/3计算资源的玩家，比特币协议也不具有激励兼容性——存在一种自私的挖掘攻击 使攻击者获得1/2奖励。

### 路线图
在第2节中，我们定义了协议执行模型和区块链协议的正式抽象。 在第3节中，我们提出了区块链协议的新公平性定义。在第4节中，我们正式介绍了FruitChain协议。 在第5节中，我们为主要定理提供了形式证明。 在第6节中，我们描述了如果给定任何（近似）公平区块链，我们可以设计支付机制以实现激励兼容性和ε-Nash均衡。最后，在第7节中，我们描述了FruitChain如何用于抑制矿池并确保区块链的分散性。

## 预备知识和定义
### 协议执行模型和符号
协议是指用于一组交互式图灵机（也称为节点）彼此交互的算法。执行由环境Z（1<sup>k</sup>）（其中κ是安全参数）引导的协议Π，其激活许多方1,2....，n作为“诚实”或损坏的方。诚实的政党会忠实地遵守协议的处方，而腐败的政党则由对手A控制，对手A读取所有输入/消息并设置他们的输出/消息。

环境Z是密码学文献中通常用于协议组成的术语——人们可以将环境Z视为包含生活在协议定义的“框”之外的所有内容的全部术语。例如，如后所述，环境Z的部分工作是为诚实节点提供输入并从中接收输出。这模拟了协议的输入可能来自外部应用程序的事实，并且协议的输出可以由外部应用程序使用，其中任何外部应用程序或系统中运行的其他协议被视为Z的一部分。

- 协议的执行以轮次进行，模拟原子时间步长。在每一轮的开始，诚实的节点接收来自环境Z的输入;在每一轮结束时，诚实的节点将输出发送到环境Z.
- A负责将各方（诚实或已损坏）发送的所有消息传递给所有其他方。A不能修改诚实玩家广播的消息内容，但只要最终传递所有消息，它就可能延迟或重新排序消息的传递。（稍后，我们将考虑对交付时间的限制。）收件人不知道发件人的身份。<sup>2</sup>
- 在任何时候，Z都可以破坏诚实的一方j，这意味着A可以访问其本地状态，然后A控制一方j。（特别是，这意味着我们考虑具有“擦除”的模型;不再存储在本地状态j中的随机硬币投掷对A不可见。）<sup>3</sup>
- 在任何时候，Z都可以破坏受损的玩家j，这意味着A不再控制j。 变为未损坏的玩家以与新产生的玩家相同的方式被对待，即，玩家的内部状态被重新初始化，然后玩家开始执行不再受A控制的诚实协议。

**随机执行的符号。** 协议的执行是随机的，其中随机性来自诚实的玩家以及控制所有损坏节点的对手A和在协议执行期间向诚实节点发送输入的环境Z。我们使用符号view←EXEC<sup>Π</sup>（A，Z，κ）来表示随机采样的执行跟踪，并且|view|表示执行跟踪视图中的回合数。更具体地说，view是随机变量，表示在上述执行中所有各方的联合视图（即，他们所有的输入，随机硬币和接收的消息，包括来自随机预言的那些）;请注意，此联合视图完全确定执行。

**对（A,Z）的约束。** 环境Z和对手A必须遵守某些约束。 我们说p.p.t. 对（A，Z）是（n，ρ，Δ）-关于w.r.t.Π，对于每个κ∈N，每个视图view支持EXEC<sup>Π</sup>（A，Z，κ)，以下成立：

1. Z在view中激活n方;
2. 对于在任何时间t由诚实玩家广播的任何消息，在时间t +Δ或更晚的时候诚实的任何玩家必须已经接收到该消息。 这意味着在新生成的玩家的情况下，立即发送超过Δ轮发送的消息。只要尊重此Δ约束，A就可以任意延迟或重新排序诚实玩家的消息。
3. 在view的任何一轮r中，A最多控制ρ·n方;并且设Γ（·，·，·）为布尔谓词。 我们说p.p.t. 对（A，Z）是符合Γ的w.r.t. 协议π,当且仅当
- （A，Z）是（n，ρ，Δ）-关于w.r.t.π; 并且
- Γ(n,ρ,∆) = 1

换句话说，Γ是一个谓词，它对（A，Z）必须遵守的参数（n，ρ，Δ）的附加约束设置约束。当上下文清楚时，我们经常说（A，Z）是Γ兼容的，而省略指定w.r.t.的那个协议。

### 2.2 公约
**作为安全性参数的函数的变量。** 除非另有说明，否则我们默认假设所有变量都是安全参数κ的函数。如果任何变量不是κ的函数，我们将明确指出变量是常量。 变量也可以是后面定义的关系的变量，其中（A，Z）必须另外满足我们的区块链协议是安全的。

对于默认为κ函数的两个变量，我们说的var<sub>1 </sub><var<sub>2 </sub>当且仅当每个κ∈N，var<sub>1 </sub>（κ）<var<sub>2 </sub>（κ）。类似地，如果我们说var是正的，我们的意思是var（κ）对于任何κ∈N都是正的。

**其他公约。** 在整篇文章中，每当我们提到p.p.t. 机器，我们的意思是机器是非均匀的概率多项式时间。

### 2.3 区块链协议
在本节中，我们回顾了来自<font color="#006600">[PSS17]</font>的区块链协议的抽象模型，并提供了我们将大量使用的Nakamoto原始区块链协议的描述。

在区块链协议Π中，节点从环境Z接收输入记录，并且节点彼此交互以便以实现一致性和活跃性的方式商定线性排序的事务日志。

**区块链协议的输入和输出。** 

在每个时间步的开始，环境Z向每个诚实玩家输入记录m。 在每个时间步骤结束时，每个诚实的玩家向环境Z输出一个链，其中链表示有序的记录序列（也称为块）。 每个记录（或块）可以依次包含有序的事务序列。 此后，我们使用符号

轮次t中节点i的输出：chain<sup>t</sup><sub>i</sub>（view）

表示在给定的执行跟踪view中，在t到Z的节点i的输出。

**工作证明建模。**  为了模拟Nakamoto的区块链协议，我们需要用随机的oracle扩展协议执行模型。在使用安全性参数κ执行时，我们假设所有各方都可以访问随机函数H：{0,1} *→{0,1}<sup>k</sup>，他们可以通过两个orcale访问：当且仅当H（x）=y则H（x）简单地输出H（x）和H：ver（x，y）输出1，否则输出0。在任何一轮中，玩家（以及A）可以对H.ver进行任意数量的查询。另一方面，在每一轮r中，诚实的玩家只能对H进行一次查询，并且控制q方的对手A可以对H进行q次序查询。（这种建模的目的是为了捕捉我们只是努力的“收取”寻找“工作证明”解决方案的假设<font color="#006600">[DN92]</font>，但检查解决方案的有效性是便宜的。我们在介绍Nakamoto的协议后进一步讨论这个问题。）我们强调环境Z不能直接访问随机oracle（但可以指示A进行查询）。

### 2.4 Nakamoto的区块链协议
我们转而描述Nakamoto的协议[Nak08]，我们将其称为Π<sub>nak</sub>（p）。Π<sub>nak</sub>（p）接受拼图难度参数p，表示每个玩家在一轮中挖掘一个块的概率。

协议概述。 在Π<sub>nak</sub>中，每个诚实节点在任何时间点都维护着一个内部状态链。每个chain[i]被称为（挖掘的）块并且具有格式chain[i]：=（h-1，η，m，h），其包含前面的块的散列，包含表示为h-1的前一个块的散列，随机数η，记录m和散列h<sup>4</sup>,设chain：=extract（chain）是块链序列中包含的记录序列。chain是诚实节点输出到环境的版本。

Π<sub>nak</sub>的工作原理如下：

- 新产生的或已经变得未损坏的节点从仅包含特殊起源块的初始链开始：chain：=（0,0，⊥，H（0,0，⊥））。
- 在每一轮中：节点读取所有传入的消息（由A传递）。 如果任何传入消息chain'是比其本地状态链长的有效块序列，则逐chain替换chain'。我们定义链条在以后有效的含义。请注意，检查chain'的有效性可以仅使用H.ver查询来完成。
- 从环境Z读取输入记录m。现在解析chain[-1]：=（_，_，_，h<sub>-1</sub>），选择一个随机的随机数η∈{0,1}<sup>k</sup>，并发出查询h=H（H<sub>-1</sub>，η，M）。如果h<D<sub>p</sub>，则将新挖掘的块（h<sub>-1</sub>，η，b，h）附加到链并广播更新的链。<br>
更具体地，D<sub>p</sub>=p（κ）·2<sup>k</sup>使得对于所有（h，m），Pr<sub>n</sub>[H（h，η，m）<D<sub>p</sub>]=p。换句话说，Dp被适当地参数化，使得任何玩家在一轮中挖掘一个块的概率是p。
- 输出chain：=extra（chain）到环境Z.请注意，符号chian仅从链中提取记录序列，删除外部应用程序不需要的所有其他元数据。

**有效链** 我们说如果两个条件成立：h<sub>-1</sub> = h'，h = H（h<sub>-1</sub>，η，m），h <D<sub>p</sub>所以块chian[i]=（h<sub>-1</sub>，η，m，h）对于（前一个块）chian[i-1]=（h'<sub>-1</sub>，n'，m'，h）是有效的。如果a）chain[0]=（0,0，⊥，H（0,0，⊥））是起源块，则b链的链是有效的，并且b）适用于所有i∈[l]，chian[i]对chian[i - 1]有效。

**备注：关于我们使用随机orcale。** 回想一下，在我们的模型中，我们将玩家限制为每轮一个评估查询H，但允许他们在同一轮中进行任意数量的验证查询。我们这样做是为了模拟检查挖掘区块的有效性是“便宜”而挖掘过程昂贵的事实。（为了实现这一点，我们在Nakamoto描述中的每个挖掘块中都包含了指向当前记录的指针h;因此玩家不需要花费H查询来计算指向前一记录的指针。）

在实践中，评估hash函数（用于实例化随机orcale）的成本与验证其输出相同，但我们的建模尝试捕获矿工通常使用各种启发式的现象（例如已发送无效块的黑名单IP地址）和不同的硬件来检查已挖掘块的有效性与挖掘新块的有效性。

### 2.5 区块链安全协议
在本节中，我们回顾了来自<font color="#006600">[PSS17]</font>的区块链的安全属性，后者又基于<font color="#006600">[GKL15，KP15]</font>的早期定义。出于我们的目的，我们稍微概括了<font color="#006600">[PSS17]</font>的属性（见下文讨论的这个概括），但指出我们的广义定义足以满足它们的所有已知应用;有关这些定义的更多讨论（和历史评论），请参见<font color="#006600">[PSS17]</font>。

**可忽略函数**  如果对于每个多项式p（·），存在一些κ<sub>0</sub>使得对于所有κ≥κ<sub>0</sub>，ε（κ）≤1/p（κ），则函数ε（·）被认为是可忽略的。

我们现在定义三个有用的属性，分别称为链增长，链质量和一致性。请注意，所有属性都是在诚实节点的环境输出上定义的，这些输出在抽象级别是可见的（而不是在节点的内部状态链上）。

#### 2.5.1 链增长
第一个需求是链条随着时间步长的增加而成比例增长。让，

min-chain-increase<sub>t,t'</sub>(view) = min
<sub>i,j</sub>|chain<sup>t+t'</sup><sub>j</sub>(view)| − |chain<sup>t</sup><sub>i</sub>(view)|

max-chain-increase<sub>t,t'</sub>(view) =max
<sub>i,j</sub>|chain<sup>t+t'</sup><sub>j</sub>(view)| − |chain<sup>t</sup><sub>i</sub>(view)|

我们在节点i，j上进行量化，这样我在第t轮是诚实的，j在第t + t'轮时是诚实的。

当且仅当以下两个属性成立，则让growth<sup>t0，t1</sup>（view，Δ， T）= 1：

- **(一致长度）** 对于所有时间步长t≤|view|-Δ，t+Δ≤t'≤|view|，对于每两个玩家i，j，使得在view中i是诚实的在t并且j在t’是诚实的，我们有|chain<sup>t'</sup><sub>j</sub>（view）|≥|chain<sup>t</sup><sub>i</sub>（view）|
- **（链增长下限）** 每个时间步t≤| view | - t<sub>0</sub>我们有min-chain-increase<sub>t,t'</sub>（view）≥T.
- **（链增长上限）** 每个时间步t≤| view | - t<sub>1</sub>我们有min-chain-increase<sub>t,t1</sub>（view）≤T.

换句话说，growth<sup>t0，t1</sup>是一个谓词，它测试a）诚实方拥有大致相同长度的链，并且b）在执行的任何t<sub>0</sub>时间步骤中，所有诚实方的链增加至少T，并且c）在执行的任何t<sub>1</sub>时间步骤中，诚实方的链条最多增加T。

**定义2.1（链增长）。** 如果对于（A，Z）所有符合Γ的p.p.t.，区块链协议Π满足Γ-环境中的（T<sub>0</sub>，g<sub>0</sub>，g<sub>1</sub>）-链增长,存在一些可忽略的函数negl，使得对于每个κ∈N，T≥T<sub>0</sub>，t<sub>0</sub>≥T/ g0和t<sub>1</sub>≤T/ g1，以下成立：

Pr[view EXEC<sup>Π</sup>(A,Z,κ):growth<sup>t0，t1</sup>(view, ∆,κ) = 1]≥ 1 − negl(κ)

#### 2.5.2 链质量
第二个需求是对手贡献的块数量不是太大。

给定一个链，我们说块B：=chain[j]是诚实的w.r.t. view和前缀chain[：j']其中j'<j如果在视图中存在某个节点i诚实在某个时间t≤|view|，这样1）chian[：j']≺chain<sup>t</sup><sub>i</sub>（view）其中≺ 在时间t，表示“是前缀”并且2）Z输入B到节点i。 非正式地，对于表示链的诚实节点链，块B：=chian[j]是诚实的w.r.t.前缀chain[：j']其中j'<j，如果之前有一些诚实节点，当其本地链包含前缀chian[：j']时，它接收B作为输入。

让quality<sup>T</sup>（view，μ）= 1当且仅当每个时间t和每个玩家i使得i在t中是诚实的，在任何连续的T块链序列中[j + 1 ..，j + T]⊆chain<sup>t</sup><sub>i</sub>（view），诚实的块的分数view和chain[：j]至少为μ。

**定义2.2（链质量）。** 区块链协议Π具有（T<sub>0</sub>，μ）-链质量，在Γ-环境中如果对于所有Γ兼容p.p.t.pair（A，Z），存在一些可忽略的函数negl，使得对于每个κ∈N且每个T≥T<sub>0</sub> 以下是：

Pr [view EXEC<sup>Π</sup>(A,Z,κ) : quality<sup>T</sup> (view,µ) = 1]≥ 1 − negl(κ)

#### 2.5.3 一致性
粗略地说，一致性规定了共同的前缀和未来的自我一致性。 公共前缀要求所有诚实节点的链，除了大约O（κ）个没有稳定的尾随块之外，必须全部同意。未来的自我一致性要求诚实节点的当前链，除了大致O（κ）数量的未稳定的尾随块之外，应该持续到它自己的未来。 这些属性可以在以下形式定义中统一（另外要求在任何时候，两个诚实节点的链必须具有相似的长度）。

让consistent<sup>T</sup>（view）=1当且仅当所有时间t≤t'，并且所有玩家i，j（可能相同）使得i在t是是诚实的并且j在t'中是诚实的，在view中，我们有前缀 chain<sup>t</sup><sub>i</sub>（view）和chain<sup>t'</sup><sub>j<sub>（view）由第一个l = | chain<sup>t</sup><sub>i</sub>（view）|——T组成的记录是相同的——这也意味着以下必须为真：chain<sup>t'</sup><sub>j<sub>（view）>l，即chain<sup>t'</sup><sub>j<sub>（view）不能比chain<sup>t</sup><sub>j<sub>（view）短得多，因为t'≥t。

**定义2.3（一致性）。** 区块链协议Π满足T<sub>0</sub>-一致性，在Γ-环境中，如果对于（A，Z）所有符合Γ的p.p.t.，存在一些可忽略的函数negl，使得对于每个κ∈N和每个T≥T<sub>0</sub>，以下成立：

Pr [view←EXEC<sup>Π</sup>(A,Z,κ):consistentT<sup> </sup>(view) = 1] ≥ 1 − negl(κ)

请注意，一致性的直接后果是，在任何时候，任何两个诚实玩家的链长最多可以相差T（除了可忽略的概率）。

### 2.6 <font color="#006600">[PSS17]</font>的预备知识：Nakamoto区块链的安全性

来自<font color="#006600">[PSS17]</font>的结果（以及我们将要看到的，也是我们的）通过以下量（针对某些固定的采矿硬度函数p（·）定义）进行参数化;回想一下，Nakamoto的协议被参数化为单个硬度参数p）：
 
- 令α：= 1 -（1-p）<sup>（1-ρ）n</sup>。也就是说，α是一些诚实的玩家成功地在一轮中阻挡一个块的概率;
- 让β：=ρnp。那就是β是攻击者可以在一轮中挖掘的预期块的数量。
- 令γ：=α/ 1+Δα。γ是α的“折扣”版本，它考虑到诚实方发送的消息可以延迟Δ轮次这一事实，这可能导致诚实的玩家“重做工作”;γ对应于它们的“有效”采矿能力。

从本质上说，这些数量是由诚实的各方和对手所期望的“链长增加”的结果;α，β被不同地定义的原因是我们假设对手可以在一轮中对其查询进行顺序化，而诚实的玩家进行单个并行查询（它们各自独立行动），因此即使他们设法挖掘了几个块，诚实玩家持有的最长链最多可增加1。但是请注意，当p很小时（与1 / n相比），这是比特币协议的情况，α很好地近似为（1 - ρ）np，因此α/β≈1-ρ/ρ，所以 这种差异很小; 另外，当p很小时，γ≈α，因此γ/β≈1-ρ/ρ。

**Nakamoto区块链的兼容执行。** 我们现在为Nakamoto区块链指定合规谓词Γ<sup>p</sup><sub>nak</sub>（·，·，·）。我们说Γ<sup>p</sup><sub>nak</sub>（·，·，·）=1，如果有一个常数λ> 1那么

α(1 − 2(∆ + 1)α) ≥ λβ

其中α和β是如上定义的参数n，ρ，Δ和κ的函数。

如Pass等人所示<font color="#006600">[PSS17]</font>，这个条件还暗示如下：

**事实2.4。**  如果（A,Z）是Γ<sup>p</sup><sub>nak</sub>-compliant，则npΔ<1。

我们直接得到以下对我们有用的推论。

**事实2.5。** 如果（A,Z）是Γ<sup>p</sup><sub>nak</sub>-compliant，那么γ≥np/8并且

证明。 回想一下，γ=α/1+Δα。由于α≤np，通过事实2.4，我们直接得到它

γ ≥α/2β

回想一下，α= 1-（1-p）<sup>（1-ρ）n</sup>。由于事实2.4，n <1 / p，通过二项式扩展我们得到了

(1 − p)<sup>（1-ρ）n</sup>< 1 − (1 − ρ)np/2

因此，γ>（1-ρ）np/4≥np/8，因为在我们的限制下，我们得到ρ<1/2。

**Nakamoto区块链的正式保证。** 以下定理在<font color="#006600">[PSS17]</font>中得到证实。

**定理2.6** （Nakamoto<font color="#006600">[PSS17]</font>的安全性）。 对于任何常数δ>0，任何0<p<1，任何超对数函数T<sub>0</sub>=ω（logκ）Nakamoto的区块链协议Π<sub>nak</sub>（p）在Γ<sup>p</sup><sub>nak</sub>-environments中满足以下属性：

- T<sub>0</sub>-一致性;
- 链增长率（T<sub>0</sub>，g<sub>0</sub>，g<sub>1</sub>）在这里</br>
g<sub>0</sub>= (1 − δ)γ</br>
g<sub>1</sub>= (1 + δ)np
- 链质量（T<sub>0</sub>,μ）在这里</br>
µ = 1 − (1 + δ)β/γ

**备注2.7** （区块链质量和一致性）。<font color="#006600">[PSS17]</font>中证明的一致性属性实际上比声明的要强一些。不仅表明玩家同意他们的区块链中包含的记录，而且还表明实际的区块链同意，除了可能是最后一个κ区块。我们将此属性称为区块链一致性，并将在续集中依赖它。

此外，链条质量属性也更强大，不仅诚实区块的记录由诚实的玩家贡献，而且实际区块由诚实玩家开采。 我们将此属性称为区块链质量，并将在续集中依赖它。

#### 2.6.1 活跃度
来自<font color="#006600">[PSS17]</font>的活跃属性（概括了<font color="#006600">[GKL15]</font>中的那个），规定从任何给定的轮次r，如果经过足够长的时间t——我们将这个时间称为区块链的等待时间——每个诚实的玩家都会在他们的链中有一个足够“深度”的记录（技术上，从链的末端开始阻塞），其中m被提供作为轮次r和r + t<sup>5</sup>之间的某个诚实玩家的输入。更确切地说，让live（view，t）=1当且仅当对于任何连续的t轮r，...，r + t在view中存在一些轮次r'st r≤r'≤r+ t和玩家i，以便在view中，1）i在r'是诚实的，2）i我在第r轮收到记录m作为输入，3）在每个玩家j中表示诚实r+t在view中，m∈chain<sup>j+t</sup><sub>j</sub>（view）[：-κ]。

定义2.8。 我们说区块链（Π，链）在Γ-环境中满足等待时间w的活跃性，如果对（A，Z）所有Γ兼容的p.p.t. ，在安全参数κ∈N中存在可忽略的函数ε，使得

Pr [view EXECΠ(A; Z; κ) : live(view; w) = 1] ≥ 1 − ε(κ)

以下定理在先前的工作<font color="#006600">[PSS17]</font>中显示。

**定理2.9** （<font color="#006600">[PSS17]</font>）。对于任何布尔谓词Γ（·，·，·），令Π为满足链增长（T<sub>0</sub>，g<sub>0</sub>，g<sub>1</sub>），链质量（T<sub>0</sub>，μ）和Γ-环境中T0链一致性的区块链协议，其中μ和g<sub>0</sub>严格为正，T<sub>0</sub>为次线性.<sup>6</sup>然后，Π满足等待时的活跃性

w = (1 + δ) κ/g<sub>0</sub>

反对在Γ环境中

作为2.9和2.6的直接推论，我们得到：

**推论2.10** （<font color="#006600">[PSS17]</font>）。 对于任何常数δ>0，任何0<p<1，Π<sub>nak</sub>（p）满足等待时间w =（1 +δ）的活跃度

在Γ<sup>p</sup><sub>nak</sub>-环境中.

## 公平性定义
我们转而定义我们的公平观念。粗略地说，区块链协议是δ-大约是公平的w.r.t.ρ攻击者如果以极大的概率，任何控制计算能力的φ分数的诚实子集都保证在每个足够长的窗口中获得至少一部分块，即使存在控制计算能力的ρ分数的对手也是如此。</br>
(1 − δ)φ</br>
注意，这个条件通常意味着（1-δ）（1-ρ）的链质量（通过考虑φ=1-ρ，即全部诚实玩家）。因此，为了正式定义这个概念，我们首先概括质量的定义（用于链质量的定义，参见定义2.2），以考虑“质量”w.r.t到诚实玩家的任何子集S.

**热身：静态腐败的公平性定义。** 作为热身，让我们考虑如何在静态腐败模型中定义（近似）公平性，其中对手必须预先声明损坏的节点。 一旦我们展示了如何做到这一点，我们就讨论如何将定义扩展到自适应损坏模型。在静态损坏模型下，我们说区块链协议满足（T，δ）近似公平性，如果以下成立除了协议执行的概率可忽略不计：对于协议执行期间任何诚实节点的链，任何常量φ>0，对于诚实用户的任何子集S，例如|S|=φ·n其中n表示用户的总数，对于链中的任何T个连续块chian[j+1..j+T]，它认为chian[j + 1..j+T]中的块的分数由S中的节点贡献的至少是（1-δ）φ。

**适应性腐败的公平性定义。** 通常，可以以自适应方式声明损坏，因此任何子集S中的节点可能在我们关心的窗口期间变得腐败。为了用自适应腐败来定义（近似）公平性，我们需要允许子集S随时间变化。 我们将下面的定义正式化。

- 让玩家子集选择S（view，r）成为给定（view，r）输出在view中的轮次r处诚实的玩家的子集的函数。
- 如果S（view，r）总是输出一组大小为φn（向上舍入），其中n是view中的玩家数量，我们说S是一个φ分数玩家的子集选择。
- 给定玩家子集选择S，我们说记录m是S兼容的w.r.t. view和前缀链如果存在一个玩家j并且轮回r'使得j在S（view，r'）中，则环境提供m作为在r'处的j的输入，并且chain≺chain<sup>r</sup><sub>i</sub>（view）其中≺ 表示“是前缀”;
- 让quality<sup>T,S</sup>（view，μ）=1当且仅当对于每一轮r和每个玩家i，使得i在轮次view中是诚实的，我们在任何连续序列的T记录chain<sup>T</sup><sub>i</sub>（view）[j+1]：j+T]，与S兼容的记录的分数w.r.t.视图和前缀chain<sup>T</sup><sub>i</sub>（view）[：j]至少为μ。

我们现在将公平定义为链式质量。

**定义3.1。** 如果对于所有符合Γ的p.p.t.（A，Z），区块链协议Π在Γ-环境中具有（近似）公平性（T<sub>0</sub>，δ）。，每个正常数φ≤1-ρ，每个φ分数子集选择S，存在一些可忽略的函数ε，使得对于每个κ∈N和每个T≥T<sub>0</sub>，以下成立：

Pr [view EXEC<sup>Π</sup>(A,Z,κ):quality<sup>T,S</sup>(view,(1 − δ)φ)) = 1] ≥ 1 − ε(κ)

作为健全性检查，请注意，如果S是完整的诚实玩家，则quality<sup>T,S</sup>（view，μ）的定义会降低到quality<sup>T</sup>（view，μ）。因此，（T<sub>0</sub>，δ）-平均值意味着（T<sub>0</sub>，（1-δ）（1-ρ）） - 链质量（通过考虑φ= 1-ρ）。 另外，当ρ≤1/ 2时，这是我们在本文中考虑的情况，

(1 − δ)(1 − ρ) = 1 − δ − ρ + δρ = 1 − [δ + (1 − δ)ρ] ≥ 1 − [2δρ + (1 − δ)ρ] = 1 − (1 + δ)ρ

因此，没有ρ大小的联盟可以获得比其“公平”的区块更多的因子（1 +δ）。

事实3.2。 如果区块链协议Π在Γ-环境中满足（T<sub>0</sub>，δ）公平性，那么它满足（T<sub>0</sub>，μ） - 链质量，其中在Γ环境中μ=（1-δ）（1-ρ）≥1 - （1 +δ）ρ 。

## 4 水果链协议
我们现在转而正式定义我们的水果链协议。 粗略地说，水果链协议将运行Π<sub>nak</sub>（p）的实例，但不是直接将记录放在区块链中，而是将记录放在表示为f的“水果”中;这些水果本身需要解决一些工作证明——具有不同的硬度参数pf;另外，我们需要一个水果从一个块上“悬挂”，该块距离记录水果的块不太远——更具体地说，水果需要“指向”链中较早的块，这也不是远离含有它的块（因此，水果不能很久以前“开采”）;新近度参数R将用于指定允许水果悬挂多远。

### 4.1 有效块，水果和区块链
为了使协议正式化，我们首先介绍一些符号：

- 我们假设随机oracleH输出长度至少为2k的字符串。 设d是一个抗冲突的哈希函数（从技术上讲，它是一个函数族，并且系列中的实例被选为公共参数;在续集中我们忽略了这个选择并简单地将其视为单个函数（对于实例，使用随机性H（0）选择。）
- 我们的协议通过两个“硬度”参数p=p，p<sub>f</sub> = p<sub>f</sub>和新近度参数R进行参数化。（p是底层Nakamoto区块链的采矿硬度参数，pf是“果实采矿”硬度参数，如上所述在上面，新近度参数将指定水果允许“悬挂”的距离;数量q=p<sub>f</sub>/p将在我们的分析中有用。

**有效的水果。** 水果的格式为f=（h-1;h';η，digest;m;h），其中每个条目表示以下内容：

- h-1指向前一个区块的参考——这个条目是水果采矿和块状采矿的模型，彼此重叠;水果实际上并不关心这个条目（是一个区块）。但是，仍然需要包含价值以便验证水果;
- h'指向水果悬挂的（最近稳定的）块——我们称h'为水果f的指针;
- η是表示难题解决方案的随机数;
- 消化是一些水果集F的消化——这是一种神器，因为水果采矿和块状采矿是彼此重叠的。该块必须包含一组表示为F的水果，但水果不关心水果，因此我们仅包括检查水果是否正确所必需的d;
- m是水果中的记录; 并且
- h是水果的哈希或参考。

我们说表示f =（h<sub>-1</sub>; h';η，digest; m; h）的水果是有效的,当且仅当

(i) H(h<sub>-1</sub>; h'; η; digest; m) = h;

(ii)[h]<sub>-κ</sub>：<D<sub>pf</sub>其中[h]<sub>-κ</sub>：表示h的最后κ位。

如果F =φ或F是一组有效果实，我们说F是一个有效的果实集合。

**有效的块。** 由于块状采矿和水果采矿是相互搭配的，因此块看起来非常像水果，除了块必须另外包括实际的水果集F.更具体地说，块具有以下格式b=（（h<sub>-1</sub>; h';η; digest;m;h）;F）其中每个条目表示以下内容：

- h<sub>-1</sub>指向前一个块的引用，这表示块延伸的链;
- h'是一种水果采矿和块状采矿的神器，背对着彼此; 一个块实际上并不关心这个领域（但是水果确实如此），但它仍然需要被包含在块验证中;
- η是表示难题解决方案的随机数;
- 消化是一些水果集F的消化，后来被包含在块中;
- m是一个记录——该块也不关心这个字段，这是两个搭载的挖掘过程的工件;
- h被称为块的引用，它是先前字段的哈希值;并且
- F是一个包括在块的水果集。

我们说用b =（（h<sub>-1</sub>; h';η; digest; m; h）; F）表示的块是有效的当且仅当

(i)digest = d（F）其中d是前面提到的抗冲突哈希函数;

(ii)F是有效的水果集;

(iii)H(h<sub>-1</sub>; h'; η; d(F); m) = h;

(iv)[h]<sub>-κ</sub>：<D<sub>pf</sub>其中[h]<sub>-κ</sub>：表示h的最后κ位。

**有效的区块链。** 我们说链条是有效的当且仅当

- chain [0] = genesis这里genesis：=（（0; 0; 0; 0;⊥; H（0; 0; 0; 0，⊥）），φ）是“起源”块;
- 对于所有i∈[1]，chain[i]：h<sub>-1</sub>=chain[i-1].h，即每个块指的是前一个块的引用;
- 对于所有i∈[l]，所有f∈chain[i].F，存在一些j≥i-R<sub>k</sub>使得f的指针是chain[j].h。

**水果的新近度。** 最后，我们说水果f最近是w.r.t.chain如果f的指针是链[-R<sub>k</sub>：]中块的引用（即链中最后一个R<sub>k</sub>块）。

### 4.2 水果链协议和我们的主要定理
表示Π<sub>fruit</sub>的水果链协议如图1所示。此后，我们说

Γ<sup>p,p<sub>f</sub>,R</sup><sub>fruit</sub> (n,ρ,∆) = 1 当且仅当Γ<sup>p</sup><sub>nak</sub>(n,ρ,∆) = 1

此外，我们假设以下数量是本文的常量：

q :=pf/p= Θ(1), R = Θ(1)

我们现在准备陈述我们的主要定理。

![avatar](https://github.com/truechain/wiki/blob/master/analysis/truechain-consensus-core/img/f1.png)
 
 图1：水果链协议。节点不仅可以用于块，也可以用于水果。 块确认“最近”的成果; 而水果确认交易。
 
 **定理4.1** （水果链的安全性）。对于任何常数0 <δ<1，任何p，pf，令R=17，κf=2qRκ，并且T<sub>0</sub>=5κf/δ。然后表示为Π<sub>fruit</sub>（p，pf，R）的水果链协议满足
 
 - κ<sub>f</sub>-consistency;
 - 链增长率(T<sub>0</sub>，g<sub>0</sub>，g<sub>1</sub>) 在这里</br>
 g<sub>0</sub> = (1 − δ)(1 − ρ)npf,</br>
g<sub>1</sub> = (1 + δ)npf
- fairness (T<sub>0</sub>, δ)

在 Γ<sup>p,p<sub>f</sub>,R</sup><sub>fruit</sub> -环境中。

## 5 主要定理的证明
我们首先介绍一些额外的符号和有用的引理，然后转向证明三个安全属性中的每一个。
### 5.1 额外的符号
让我们介绍一些在协议分析中有用的附加符号：

- 我们说如果r的第一次H输出h，则在第r轮开采果实f =（h<sub>-1</sub>; h';η，digest; m; h）。
- 我们说如果r的第一次H输出h，则在第r轮开采块b =（（h<sub>-1</sub>; h';η，digest; m; h）F）。
- 我们说一个块/果实是由一个诚实的玩家开采的，如果有一个诚实的玩家首先开采它。

为了简化表示法，除了先前定义的参数α，β，γ之外，我们还定义了关于“果实采矿”过程的α和β的类似物：

- 设α<sub>f</sub>=（1-ρ）<sub>npf</sub>（即一轮中诚实玩家开采的预期果实数量）;
- 设β<sub>f</sub>=ρ<sub>npf</sub>（即一轮中腐败玩家开采的预期果实数量）。
### 5.2 水果新鲜度引理
在本节中，我们提出了一个证明FruitChain协议关键属性的引理：任何由诚实玩家挖掘的水果都将被整合到链中（因此永远不会丢失）。我们将其称为水果新鲜度引理——水果保持“新鲜”（即最近）足够长以便加入。

让fruitfreshness（view，w，κ）=1当且仅当每个诚实的玩家i和每一轮r<|view|-w，如果i在轮次r中挖掘水果，那么对于每个诚实的玩家j，存在一些指数pos，使得f在记录链中的位置pos（w.r.t.Nakamoto的协议）j在每一轮r'≥r+w（即，f∈chain<sup>r'</sup><sub>j</sub>（view）[pos]）并且另外pos至少是从链末端起的κ位置。

让</br>
wait = 2∆ + 2κ/γ

**引理5.1。**设R=17.对于任何p，pf，Γ<sup>p,pf,R</sup><sub>fruit</sub>compliant（A，Z），存在可忽略的函数ε，使得对于任何κ∈N，

Pr←[view EXEC<sup>Πfruit(p,pf,R)</sup>(A,Z,κ): fruitfreshness(view,wait,κ) = 1]≥ 1 − ε(κ)

证明。 忽视区块链一致性（参见备注2.7），活跃度和链增长失败事件——它们只能以可忽略的概率发生。 设wait =wait（κ，n，ρ，Δ）。

- 通过区块链一致性，在执行的任何时刻，只要一个诚实的玩家挖掘果实f，果实所指向的区块就位于每个诚实玩家的区块链上的某个固定位置，在现在和将来的每个时间。（回想一下，诚实的玩家会尝试挖掘果实，这些果实会指向一个阻碍κ回到链中的块，因此一致性条件就会开始。）让l表示挖掘f的玩家链的长度; 根据定义pos = l-κ。
- 通过协议的描述，如果果实f在轮次r'处开采，则所有诚实的玩家都可以看到轮次r'+Δ;此外，当发生这种情况时，所有诚实的玩家都会尝试将f添加到他们的链中，只要它仍然是最近的（w.r.t.所有诚实的玩家）。
- 通过活跃性，因此f被合并到所有诚实玩家的记录链中某个pos位置，至少是来自他们链的末端的κ记录。</br>
r' + ∆ + (1 + δ)κ/γ≤ r' + wait − ∆

只要f是最近的那个（w.r.t.所有诚实的玩家）

- 由链上增长的上限，最多</br>
(1 + δ)np(∆ + 2κ/γ)

块在时间wait-Δ中“增加”;更准确地说，通过轮次r'+等待 - Δ，没有诚实的玩家曾经有过这样的长度l'链

l' >l+ (1 + δ)np (∆ + 2κ/γ)

因此，通过轮次r'+wait-Δ，对于每个这样的诚实玩家的链长l'我们有

pos=l− κ≥ l'−κ−(1 + δ)np(∆+2κ/γ)

通过我们的合规假设以及事实2.4和事实2.5，我们得到γ≥np/8和npΔ<1，因此

pos ≥ l' − κ − (1 + δ) − (1 + δ)16κ ≤ 17κ =l'− Rκ

这意味着f仍然是最近的，直到轮次r'+waitΔ w.r.t. 所有诚实的玩家。

- 最后，通过一致性，所有诚实的玩家都同意在r'+ wait-Δ之后的任何时刻在区块链中的位置pos处找到f; 另外，通过一致的长度属性，所有诚实的玩家同意位置pos至少是从链的末端起的r'+ wait - Δ+Δ= r'+ wait。

我们还观察了关于等待的以下事实，即在wait+2步期间所有玩家开采的预期果实数量上限为k<sub>f</sub>。

**事实5.2。** 对于任何p，pf，任何的Γ<sup>p,pf,R</sup><sub>fruit</sub>compliant（A，Z）

(wait + 2) · npf ≤ k<sub>f</sub>

证明。 注意，根据事实2.4和事实2.5，我们得到γ≥np/ 8和npΔ<1，因此

(wait + 2) · npf = (2∆ + 2κ/γ+ 2) · qpn ≤ 2q + 2κ · 8q + 2 ≤ 2qR<sub>κ</sub> = k<sub>f</sub>

### 5.3 一些简化假设
为了证明我们的主要定理，我们陈述了一些可以在不失一般性的情况下做出的简化假设。这些假设（均来自随机orcaleH的属性）将在我们的后续分析中证明是有用的。

- **WLOG1：** 我们可以不失一般性地假设诚实的玩家永远不会在相同的输入上查询RO——更准确地说，我们分析了一个实验，如果某个诚实玩家想要在“旧”输入上查询它，它会重新采样nonce直到输入是“新的”;因为nonce是从{0,1}<sup>κ</sup>中选择的，所以这个“重新采样”实验与真实的实验相同，除了概率可以忽略不计，因此我们可以对它进行WLOG分析。
- **WLOG2：** 我们可以在不失一般性的情况下假设任何指向在时间t首次开采的块b的水果已经在t之后开采。此外，任何指向有效链中b之后的块的水果必须在t之后开采。 （如果没有，我们可以在查询H之前预测某些输入上的随机orcaleH的结果，这是一个矛盾。我们省略了标准细节。）
- **WLOG3：** 我们可以假设，不失一般性，诚实玩家开采的所有水果都是“新的”（即与先前玩家所见的所有有效水果不同）; 接下来是WLOG1以及在随机orcale中看到碰撞的概率可以忽略不计的事实（通过随机oracle查询数量的简单联合约束）。
- **WLOG4：** 我们可以假设在不失一般性的情况下，在r之前的某些诚实玩家链中出现的任何有效水果都是在r之前开采的; 这是随机oracle的不可预测性（以及随机oracle查询数量的简单联合）。
- **WLOG5：** 我们可以假设没有“区块链冲突”而没有失去一般性——即，没有两个不同的有效块序列以相同的块结束。

现在我们来证明这三个安全属性。

### 5.4 水果一致性证明
忽视链增长和一致性，以及区块链质量（参见备注2.7）失败事件发生的概率可以忽略不计。考虑一些支持EXEC<sup>Πfruit（p，pf，R）</sup>（A，Z，κ），轮次r，r's.t.r'≥r，并且在view中玩家i，j分别在r，r'是诚实的。通过一致性，链的i，j在r，r'的是一致的，除了可能是i的链中的最后一个κ块——让C = b<sub>0</sub>，...，b <sub>| C |</sub> 表示他们同意的那些初始块，并且让b<sub>| C |+ 1</sub>，...表示链在r的i中的（max κ）块，它们不在r'的j中;我们现在绑定可以包含在这些剩余（max κ）“不一致”块中的水果数量。

- 通过有效果实的“新近条件”，在C之后链在r的i中的任何有效果实必须指向块bj'，使得j'> | C | - R<sub>κ</sub>。
- 通过区块链质量条件，存在一些j's.t. | C | - R<sub>κ</sub>-κ≤j''≤|C|-R<sub>κ</sub>和b<sub>j''</sub>是由一个诚实的玩家开采的。设r'<sub>0</sub>表示该块开采时的轮次。
- 注意，在r'<sub>0</sub>处，b<sub>j''</sub>是由一个持有长度j''≥|C|-R<sub>κ</sub>-κ链的诚实玩家开采的; 另外，在r，i是诚实的，最多持有一个长度链| C | +κ（回想一下|C|包含i和j同意的块，并且通过一致性，除了链中的最后一个κ块之外的所有块i必须在j的链中。)因此，通过链增长上限，至多

µ = (1 + δ)2κ + Rκ/np

因此可以在r'<sub>0</sub>和r之间经过一轮。

- 通过WLOG2，任何在C之后添加的水果必须在r'<sub>0</sub>之后开采。通过WLOG4，作为链i中r的一部分的任何这样的果实在r之前被开采。
- 因此，我们通过Chernoff界（见引理A.1）得出结论，对于每个足够小的δ'，除了概率e<sup>-Ω（npf·κ（R + 2）np）</sup>= e<sup>-Ω（q（R + 2）） κ）</sup>，最多

(1 + δ')<sup>2</sup>·npf·κ(R+2)/np=(1+δ')<sup>2</sup>q(R + 2)κ < 2qRκ =κ<sub>f</sub>

在链i中r的“不一致的”果实。

### 5.5 果实增长的证明
**一致的长度。** 一致的长度属性直接来自底层区块链的一致长度属性。

**下界。** 忽视水果新鲜度失败事件（引理5.1）——它的概率可以忽略不计。考虑任何r，t和玩家i，j分别在r和r + t处是诚实的。考虑从第r轮开始的t轮。

- 通过水果新鲜度条件，由一些诚实的一方通过轮次r + t - wait开采的每个水果被r+t并入（并保持在）玩家j的链中。
- 通过Chernoff界限，在t - wait轮次从r到r + t - wait，除了概率为e<sup>-Ω（（t-wait）α<sub>f</sub>）</sup>，诚实的各方至少开采</br>
(1 − δ')(t − wait)α<sub>f</sub></br>
水果（其中δ'是一些任意小的常数），它们都包含在r + t的j链中。另外，通过WLOG3，它们都是“新的”（即，不包括在r的链i中）并且不同。
- 最后，通过果实一致性（见5.4节），我们知道r中链i中果实的所有潜在κ<sub>f</sub>仍然在r + t的链j中。
- 我们得出结论，除了概率为e<sup>-Ω（（t-wait）α<sub>f</sub>）</sup>之外，r+t处的j链至少包含</br>
(1 − δ')(t −wait)α<sub>f</sub>−κ<sub>f</sub></br>
比r的链j更多的果实。通过事实5.2，wait·α<sub>f</sub>=wait·（1-ρ）np<sub>f</sub>≤（1-ρ）κ<sub>f</sub>≤κ<sub>f</sub>; 因此，至少有</br>
(1 − δ)(t − wait)α<sub>f</sub> −κ<sub>f</sub>≥ (1 − δ)α<sub>f</sub> t − 2κ<sub>f</sub></br>
新水果。

我们得出结论指出，这意味着在期望的区域中水果增长下限为g<sub>0</sub>=1/1+δαf≥（1-δ）αf：考虑任何T≥5κf/δ且任何

t ≥T/g<sub>0</sub>=T/αf/1+δ

如上所示（见公式1），在此时间t内，除了概率，e<sup>-Ω（（t-wait）αf）</sup>链必须至少增长

T(1 + δ)(1 − δ') − 2κ<sub>f</sub> = T(1+δ/2)(1 − δ') + Tδ/2(1 − δ) − 2κ<sub>f</sub>

对于足够小的δ'，第一项大于T，第二项大于2k<sub>f</sup>，因此链必须增长至少T.最后注意通过等式<sup>1</sup>

e<sup>−Ω((t−wait)α<sub>f</sub>)</sup>=e<sup>−Ω((tα<sub>f</sub>−κ<sub>f</sub>)</sup>=e<sup>−Ω((T−κ<sub>f</sub>)</sup>=e<sup>−Ω((5κ<sub>f</sub> −κ<sub>f</sub>)</sup>=e<sup>−Ω((5κ<sub>f</sub>−κ<sub>f</sub>)</sup>=e<sup>−Ω(κ)</sup>

因此，除了可忽略的概率外，链增长得到保证。

**上界。** 忽视链增长，一致性和区块链质量（参见备注2.7）失败事件发生的概率可以忽略不计。考虑支持EXEC<sup>Πfruit（p，pf，R）</sup>（A，Z，κ），轮r，r'=r+t和玩家i，j分别在view中的r和r'处是诚实的。通过一致性，i，j在r，r'的链是一致的，除了可能是链i的最后一个κ块——让C=b<sub>0</sub>，...，b<sub>|C|</sub>表示他们同意的那些初始块，并且让b<sub>|C|+1</sub>，...表示在r'处的链j中的块，其不在r的链i中（因为我们在稍后的时间r'看到链j，所以可能存在多于κ这样的块);我们现在上限在C之后的j链中的新块中的果实数量，类似于果实一致性证明（它们的主要区别在于我们现在考虑j的链而不是i的链）。 详情如下：

- 通过有效果实的“新近条件”,在r'处的j链中的任何有效果实，其在C之后必须指向块b<sub>j'</sub>，使得j'>| C |-Rκ，
- 通过区块链质量条件，存在一些j's.t. | C | - Rκ-κ≤j''≤| C|-RK和bj''是由一个诚实的玩家开采的。 让r''表示该块开采时的轮次。
- 注意，在r'<sub>0</sub>处，b<sub>j''</sub>是由一个持有长度j''≥| C|-Rκ-κ链的诚实玩家开采的; 另外，在r，i是诚实的，最多持有一条链长|C|+κ（回想一下| C |包含i和j同意的块，并且通过一致性，除了链中的最后一个κ块之外的所有块i必须在j的链中。 因此，通过链增长上限，对于任何任意小的δ'至多

µ = (1 + δ')2κ + Rκ/np

因此可以在r'<sub>0</sub>和r之间经过一轮。

- 通过WLOG2，任何在C之后添加的水果必须在r'<sub>0</sub>之后开采。通过WLOG4，在r'之前开采的任何此类水果都是r链j中的一部分。
- 因此，我们通过Chernoff结论得出结论，除了概率为e<sup>-Ω（npf·κ（R+2）/np）</sup>=e<sup>-Ω（q（R + 2）κ）</sup>之外，最多</br>
(1 + δ')<sup>2</sup> · npf · (κ(R + 2)/np + t) = (1 + δ')<sup>2</sup>(q(R + 2)κ + npft) ≤ κf + (1 + δ')<sup>2</sup>npft</br>
r'中链j的“新”果实。

我们得出结论，指出这意味着在期望的方案中g<sub>1</sub> =（1+δ）npf的果实生长上限：考虑任何T≥5κf/δ和任何

t =T/g<sub>1</sub>=T(1 + δ)/npf

如上所示（见公式2），在此时间t内，除了可忽略的概率外，链条必须至多增长

κf + (1 + δ')<sup>2</sup>T(1 − δ) ≤ Tδ/5 + (1 + δ')<sup>2</sup>T/(1 + δ)

对于任何0 <δ<1且δ'=0.1δ，上述表达式由T上限。

### 5.6 水果公平性的证明
无视链条增长，区块链质量（参见备注2.7），水果新鲜度和果实生长失败事件发生的概率可以忽略不计。考虑一些φ-分数玩家子集选择S，一些视图view支持EXEC<sup>Πfruit（p，pf，R）</sup>（A，Z，κ），一些轮次r和玩家i在轮次r的view中是诚实的。设C = b<sub>0</sub>，...，b<sub>|C|</sub>在view中i是视图中的块，让f<sub>0</sub>，...，f<sub>l</sub>成为它们中包含的果实，让m<sub>0</sub>，...，m<sub>l</sub>成为果实中包含的记录;令f<sub>j</sub>，...，f<sub>j+T</sub>为某些j的T连续果实，其中T≥5κf/δ.

当r在包含f<sub>j+κf</sub>的视图i中的块首次被添加到某个诚实的玩家j<sub>0</sub>的链中时，让r<sub>0</sub>成为轮次;让r<sub>1</sub>成为轮次时，包含f<sub>j+T</sub>的块（再次在i的视图中）首先被添加到某个诚实的玩家j<sub>1</sub>的链中，并且让t=r<sub>1</sub>-r<sub>0</sub>-2成为来自r<sub>0</sub>+1到r<sub>1</sub>-1的轮数。我们降低了序列中S兼容（诚实）果实的数量，遵循类似的线（但稍微复杂一点）来证明水果生长下限：

- 通过水果新鲜度条件，在（r<sub>0</sub>+1）和（r<sub>0</sub>-1）-wait之间由一些诚实玩家开采的每一个水果将在链条末端至少κ位置的某个位置的j1链中,在第r1轮开始之前，将保持如此。
- 通过Chernoff的界限，在t-wait轮次从r<sub>0</sub>+1到（r<sub>1</sub>-1）-wait，除了概率为e<sup>-Ω（（t-wait）φnpf）</sup>，S矿井中的诚实党派至少you

(1 − δ')(t − wait)φnpf

水果（其中δ'是一些任意小的常数），因此它们都在r<sub>1</sub>- 1被包含在j<sub>1</sub>链中。

- 由于水果按包含它们的块排序，并且由于在轮次r1中添加了一个包含f<sub>j+T</sub>的新块，因此从区块链一致性来看，所有这些水果都包含在序列f<sub>1</sub>，...，f<sub>j+T</sub>中（回想一下，所有这些果实都是在链条末端至少处于κ位置的块中找到的，因此通过一致性，这些块不能改变，因此不会在轮次r1中添加，因此必须在包含f<sub>j+T</sub>的块之前出现。
- 通过WLOG3，这些水果也都是“新的”（即，不包括在r<sub>0</sub>的j<sub>0</sub>链中）并且不同。 由于在轮次r<sub>0</sub>中，包含f<sub>j+κf</sub>的块被添加到j<sub>0</sub>的链中，并且由于WLOG5，在r<sub>0</sub>处的j<sub>0</sub>链直到（并且包括）包含f<sub>j+κf</sub>的块是C的前缀，所有这些果实必须包含在序列f<sub>j+κf</sub>，...，f<sub>j + T</sub>中。
- 最后，通过果实一致性，在r<sub>0</sub>所有诚实玩家的水果链包含f<sub>1</sub>，...，f<sub>j</sub>（因为回想起一些玩家在r<sub>0</sub>处添加了f<sub>j +κf</sub>）。因此，在我们考虑的T段之前，所有这些果实都是S兼容的，前缀为f<sub>1</sub>，...，f<sub>j-1</sub>。

我们继续表明t足够大。回想一下j<sub>0</sub>在r<sub>0</sub>是诚实的，而j<sub>1</sub>在r<sub>1</sub>是诚实的。我们知道在r<sub>1</sub>，水果链至少含有f<sub>j+T</sub>果实。此外，在r<sub>0</sub>，果实f<sub>j+κf</sub>首次加入，因此通过果链一致性，此时最多j2kf果实可能已经在i链中（因为j +κf处的果实被修饰））。因此，果链必须从r<sub>0</sub>到r<sub>1</sub>至少增长T-2κf。通过果实生长的上限（见公式<sub>2</sub>），我们得到了这一点

T − 2κf ≤ κf + (1 − δ,)<sub>2</sub>npf(t + 2)

因此，

t ≥1/(1 + δ')<sub>2</sub>npf (T − 3κf) − 2

我们得出结论：（除了概率可以忽略不计）序列中的果实数量至少为：

(1 − δ')φnpf (1/(1 + δ')<sub>2</sub>npf (T − 3κf) − 2 − wait)=</br>
(1 − δ')φ (1/(1 + δ')<sub>2</sub> (T − 3κf) − npf(wait + 2)) ≥</br>
(1 − δ')φ (1/(1 + δ')<sub>2</sub>(T − 3κf) − κf)≥</br>
(1 − δ')φ (1/(1 + δ')<sub>2</sub>(T − 4.5κf))≥</br>
φ(T − 5κf)

其中第一个不等式遵循事实5.2，第二个和第三个不等式遵循足够小的δ'。由于T≥5κf/δ，我们得到（1-δ）T≥T-5κf，因此序列中的果实数量至少是

(1 − δ)φT

## 6 从公平到激励相容
我们注意到，任何满足δ近似公平性（其中δ<0.3）w.r.t T（κ）长度窗口的安全区块链协议都可以用作加密货币系统下的分类账，同时如果玩家（即矿工）只关心他们收到多少钱，则确保3δ-激励兼容性——也就是说，矿工的效用是它收到的奖励和交易费用的总和（可能是某些常数）.<sup>8</sup>

考虑使用区块链协议作为底层分类账的加密货币;我们省略了什么的正式化，但考虑到比特币这样的系统，其中奖励和交易费用以某种方式分配给块的矿工——例如，回想一下，在比特币中，区块的矿工获得采矿奖励以及其开采的区块中包含的所有交易费用。

我们说诚实的采矿是一种ρ-联盟-安全的ε-Nash均衡，如果以极大的概率，没有ρ'<ρ分数联盟可以获得超过效用的倍增因子（1+ε），无论交易是什么正式处理，考虑一些提供系统交易的环境。我们限制在一个设置中，系统运行期间的总奖励和交易费用是固定常数V。,<sup>9</sup>

我们现在注意到，如果奖励和交易费用均匀地分布在块之前的链的T（κ）长度段中的（矿工）块中（并且在初始阶段，在链长度为T之前（κ），简单地说就是第一个T（κ）块然后它遵循诚实的挖掘是一个ρ-联盟-安全的3δ-Nash均衡，只要下面的区块链满足δ-近似公平性w.r.t。ρ攻击者：如上所述，公平性意味着无论联盟执行什么偏差，以极大的概率，链中任何T（κ）长度窗口中的对抗块的分数上限为（1+δ）ρ，因此，攻击者收到的补偿总额（1+δ）ρ·V的限制;相反，通过公平，如果联盟一直遵循诚实的协议，他们保证至少得到（1 - δ）ρ·V; 因此，效用的乘法增加是

1 + δ/1 − δ ≤ 1 + 3δ

这里δ < 0.3.<sup>10</sup>

要了解为什么“标准”比特币方法为块的矿工提供所有奖励和费用不起作用，请考虑一个新开采（诚实）的块，其中包含交易费用非常高的交易。控制计算能力的一小部分的联盟将有一个巨大的动机来“放弃”这个块，而是试图挖掘一个包含它的新块。公平并不能阻止这种攻击，事实上，即使在我们的协议中，这样的攻击也会以不变的概率成功。（实际上，在比特币社区中已经非正式地推测，由于正是这个原因，在交易费用存在的情况下ε-激励兼容性是不可能实现的。我们在一个细分市场上分配费用的方法克服了这个“障碍”。）

## 7 抑制矿池
比特币协议（依赖于Nakamoto的区块链协议）的一个问题是挖掘硬度设置为使得世界（合并）每10分钟找到一个新区块——如<font color="#006600">[PSS17]</font>所示，采矿硬度需要以确保一致性的方式设定。这不仅会导致较长的延迟（可以通过上面讨论的混合共识方法来解决），而且也导致了一个问题，即一个矿工可能需要很长时间才能成功开采一个区块并因此获得对其工作的奖励。换句话说，矿工收到的付款差异非常大。这导致了采矿池的建立，矿工聚集在一起并集中他们的工作，然后一旦池中的某个人开采块，就会分享奖励——这样的集合会减少差异。为了防止搭便车，矿工们提交了“部分工作证明”（即“近似”采矿难题的解决方案），这些解决方案更容易找到，并且奖励是在部分工作证明的贡献者之间分配的（根据一些分配规则）。

这种池的不良影响是池操作员有效地控制了大量参与者并且可能使他们偏离;从某种意义上说，系统的分散性质会丢失。

我们注意到，由于水果链协议通过两个采矿硬度参数化——块硬度p和果实硬度pf——它们彼此独立，我们可以适当地设置p以确保一致性，但是pf可以设置为更大 - 例如，与在矿池中找到部分工作证明的概率一样大——因此，我们将以与采矿池完全相同的方式减少矿工收到的奖励差异， 但现在以完全分散的方式。

今天，一个独立采矿者（假设一个典型的商品采矿ASIC单位）需要2到5年才能获得第一笔奖励[sol]。使用水果链，假设我们为每个块分配1000个水果的空间，每个水果为80字节（与比特币难题解决方案相同），这将占据1MB块的大约8％。然而，这将允许一个独立采矿者获得第一次奖励的速度提高1000倍，大约在一天（或几天）而不是几年。

## 参考文献
[sol] http://www.coinwarz.com/calculators/bitcoin-mining-calculator.

[BCL<sup>+</sup>05] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin.Secure computation without authentication.In CRYPTO’05, 2005.

[BHP<sup>+</sup>] Iddo Bentov, Yuncong Hu, Rafael Pass, Elaine Shi, and Siqiu Yao.Decentralized pooled mining: An implementation of fruitchain. Manuscript.

[BPS16] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake.Cryptology ePrint Archive, Report 2016/919, 2016.http://eprint.iacr.org/2016/919.

[CKWN16] Miles Carlsten, Harry A. Kalodner, S. Matthew Weinberg, and Arvind Narayanan. On the instability of bitcoin without the block reward. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria,October 24-28, 2016, pages 154{167, 2016.

[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO’92, pages 139{147, 1992.

[ES14] Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vulnerable.In Financial Cryptography and Data Security, pages 436{454. Springer, 2014.

[GKL15] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol:Analysis and applications. In Advances in Cryptology-EUROCRYPT 2015, pages 281-310. Springer, 2015.

[HP15] Joseph Y. Halpern and Rafael Pass. Algorithmic rationality: Game theory with costly computation. J. Economic Theory,156:246{268, 2015.

[KKKT16] Aggelos Kiayias, Elias Koutsoupias, Maria Kyropoulou, and Yiannis Tselekounis.Blockchain mining games. In Proceedings of the 2016 ACM Conference on Economics and Computation, EC ’16, pages 365-382, 2016.

[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols, 2015.

[KP16] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. IACR Cryptology ePrint Archive, 2016:545, 2016.

[KRDO16] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov.Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report2016/889,2016.http://eprint.iacr.org/2016/889.

[LSZ15] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain protocols. In Financial Crypto’15,2015.

[mtg10] mtgox.https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606,2010.

[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.

[NKMS16] Kartik Nayak, Srijan Kumar, Andrew Miller, and Elaine Shi. Stubborn mining: Generalizing selfish mining and combining with an eclipse attack. In IEEE European Symposium on Security and Privacy, EuroS&P 2016,Saarbr¨ucken,Germany, March 21-24,2016, pages 305-320, 2016.

[PSS17] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in networks. In Eurocrypt, 2017.

[PS16] Rafael Pass and Elaine Shi. Hybrid consensus. http://eprint.iacr.org/2016/917,2016.

[SSZ16] Ayelet Sapirshtein, Yonatan Sompolinsky, and Aviv Zohar. Optimal selfish mining strategies in bitcoin. In Financial Crypto’16,2016.

[SZ15] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507-527, 2015.

## A 附录
我们记得标准的Chernoff界限。

**引理A.1** （乘法Chernoff界）。设X<sub>1</sub>，...，X<sub>n</sub>是独立的布尔随机变量，这样对于所有i，Pr[X<sub>i</sub>=1]=p;设X是这些变量的总和，μ是和的期望值。那么对于任何δ∈（0,1），我们都有

Pr[X > (1 +δ)µ]<e<sup>−Ω(δ<sub>2</sub>µ)</sup>

Pr[X < (1 −δ)µ]<e<sup>−Ω(δ<sub>2</sub>µ)</sup>













 
