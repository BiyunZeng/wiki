## 椭圆加密描述：
在以太坊中，椭圆加密的作用是签名验证的作用，不是我们所理解的
jia mi     asd ad asd asd a   




## 算法描述：





## 代码
package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
	"fmt"
)

func main(){
	//siag and verify

	//生成明文
	message:=[]byte("hello world")
	fmt.Println("明文是: hello world")

	//通过随机值, 得到私钥
	privateKey,_:=ecdsa.GenerateKey(elliptic.P256(),rand.Reader)

	pub:=privateKey.PublicKey

	//明文散列处理，第一次加密, 在以太坊中, 真正机密之前也进行了哈希散列处理
	Dig:=sha256.Sum256(message)


	//椭圆签名生成证书, 这里用到的参数有 私钥, 散列后明文
	r,s,_:=ecdsa.Sign(rand.Reader,privateKey,Dig[:])
	fmt.Println("密文r,s分别是:\nr:",r,"\ns:",s)
	//设置私钥参数类型为曲线
	param:=privateKey.Curve.Params()

	//获得私钥Ｋｅｙ　ｂｙｔｅ长度
	curveOrderByteSize:=param.P.BitLen()/8

	//获得签名返回值的　字节长度
	rbyte,sByte:=r.Bytes(),s.Bytes()


	//创建一个数组，长度是密钥字节长度两倍
	signatue:=make([]byte,curveOrderByteSize*2)

	//通过数组保存了签名结果的返回值
	copy(signatue[curveOrderByteSize-len(rbyte):],rbyte)
	copy(signatue[curveOrderByteSize*2-len(sByte):],sByte)

//----------------------------------------------------------
fmt.Println("------------------------------------------------------------")
fmt.Println("下面是验证密文部分")
//下面是验证部分代码

	//verify
	//将明文Ｈａｓｈ散列，为了验证内容对比

	Dig=sha256.Sum256(message)

	curveOrderByteSize=pub.Curve.Params().P.BitLen()/8
	r,s=new(big.Int),new(big.Int)

	//设置证书值
	r.SetBytes(signatue[:curveOrderByteSize])
	s.SetBytes(signatue[curveOrderByteSize:])

	//verify
	e:=ecdsa.Verify(&pub,Dig[:],r,s)

	if e==true{
		fmt.Println("succussful")
	}else{
		fmt.Println("failed")
	}

}
